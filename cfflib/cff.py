#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Mon Jan 17 18:32:32 2011 by generateDS.py version 2.3b.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_str_lower(self, instring):
            return instring.lower()
                    
                    

#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
STRING_CLEANUP_PAT = re_.compile(r"[\n\r\s]+")

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class connectome(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, connectome_meta=None, connectome_network=None, connectome_surface=None, connectome_volume=None, connectome_track=None, connectome_timeserie=None, connectome_data=None, connectome_script=None, connectome_imagestack=None):
        self.connectome_meta = connectome_meta
        if connectome_network is None:
            self.connectome_network = []
        else:
            self.connectome_network = connectome_network
        if connectome_surface is None:
            self.connectome_surface = []
        else:
            self.connectome_surface = connectome_surface
        if connectome_volume is None:
            self.connectome_volume = []
        else:
            self.connectome_volume = connectome_volume
        if connectome_track is None:
            self.connectome_track = []
        else:
            self.connectome_track = connectome_track
        if connectome_timeserie is None:
            self.connectome_timeserie = []
        else:
            self.connectome_timeserie = connectome_timeserie
        if connectome_data is None:
            self.connectome_data = []
        else:
            self.connectome_data = connectome_data
        if connectome_script is None:
            self.connectome_script = []
        else:
            self.connectome_script = connectome_script
        if connectome_imagestack is None:
            self.connectome_imagestack = []
        else:
            self.connectome_imagestack = connectome_imagestack
    def factory(*args_, **kwargs_):
        if connectome.subclass:
            return connectome.subclass(*args_, **kwargs_)
        else:
            return connectome(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_connectome_meta(self): return self.connectome_meta
    def set_connectome_meta(self, connectome_meta): self.connectome_meta = connectome_meta
    def get_connectome_network(self): return self.connectome_network
    def set_connectome_network(self, connectome_network): self.connectome_network = connectome_network
    def add_connectome_network(self, value): self.connectome_network.append(value)
    def insert_connectome_network(self, index, value): self.connectome_network[index] = value
    def get_connectome_surface(self): return self.connectome_surface
    def set_connectome_surface(self, connectome_surface): self.connectome_surface = connectome_surface
    def add_connectome_surface(self, value): self.connectome_surface.append(value)
    def insert_connectome_surface(self, index, value): self.connectome_surface[index] = value
    def get_connectome_volume(self): return self.connectome_volume
    def set_connectome_volume(self, connectome_volume): self.connectome_volume = connectome_volume
    def add_connectome_volume(self, value): self.connectome_volume.append(value)
    def insert_connectome_volume(self, index, value): self.connectome_volume[index] = value
    def get_connectome_track(self): return self.connectome_track
    def set_connectome_track(self, connectome_track): self.connectome_track = connectome_track
    def add_connectome_track(self, value): self.connectome_track.append(value)
    def insert_connectome_track(self, index, value): self.connectome_track[index] = value
    def get_connectome_timeserie(self): return self.connectome_timeserie
    def set_connectome_timeserie(self, connectome_timeserie): self.connectome_timeserie = connectome_timeserie
    def add_connectome_timeserie(self, value): self.connectome_timeserie.append(value)
    def insert_connectome_timeserie(self, index, value): self.connectome_timeserie[index] = value
    def get_connectome_data(self): return self.connectome_data
    def set_connectome_data(self, connectome_data): self.connectome_data = connectome_data
    def add_connectome_data(self, value): self.connectome_data.append(value)
    def insert_connectome_data(self, index, value): self.connectome_data[index] = value
    def get_connectome_script(self): return self.connectome_script
    def set_connectome_script(self, connectome_script): self.connectome_script = connectome_script
    def add_connectome_script(self, value): self.connectome_script.append(value)
    def insert_connectome_script(self, index, value): self.connectome_script[index] = value
    def get_connectome_imagestack(self): return self.connectome_imagestack
    def set_connectome_imagestack(self, connectome_imagestack): self.connectome_imagestack = connectome_imagestack
    def add_connectome_imagestack(self, value): self.connectome_imagestack.append(value)
    def insert_connectome_imagestack(self, index, value): self.connectome_imagestack[index] = value
    def export(self, outfile, level, namespace_='', name_='connectome', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='connectome')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='connectome'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='connectome'):
        if self.connectome_meta:
            self.connectome_meta.export(outfile, level, namespace_, name_='connectome-meta', )
        for connectome_network_ in self.connectome_network:
            connectome_network_.export(outfile, level, namespace_, name_='connectome-network')
        for connectome_surface_ in self.connectome_surface:
            connectome_surface_.export(outfile, level, namespace_, name_='connectome-surface')
        for connectome_volume_ in self.connectome_volume:
            connectome_volume_.export(outfile, level, namespace_, name_='connectome-volume')
        for connectome_track_ in self.connectome_track:
            connectome_track_.export(outfile, level, namespace_, name_='connectome-track')
        for connectome_timeserie_ in self.connectome_timeserie:
            connectome_timeserie_.export(outfile, level, namespace_, name_='connectome-timeserie')
        for connectome_data_ in self.connectome_data:
            connectome_data_.export(outfile, level, namespace_, name_='connectome-data')
        for connectome_script_ in self.connectome_script:
            connectome_script_.export(outfile, level, namespace_, name_='connectome-script')
        for connectome_imagestack_ in self.connectome_imagestack:
            connectome_imagestack_.export(outfile, level, namespace_, name_='connectome-imagestack')
    def hasContent_(self):
        if (
            self.connectome_meta is not None or
            self.connectome_network or
            self.connectome_surface or
            self.connectome_volume or
            self.connectome_track or
            self.connectome_timeserie or
            self.connectome_data or
            self.connectome_script or
            self.connectome_imagestack
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='connectome'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.connectome_meta is not None:
            showIndent(outfile, level)
            outfile.write('connectome_meta=model_.CMetadata(\n')
            self.connectome_meta.exportLiteral(outfile, level, name_='connectome_meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('connectome_network=[\n')
        level += 1
        for connectome_network_ in self.connectome_network:
            showIndent(outfile, level)
            outfile.write('model_.CNetwork(\n')
            connectome_network_.exportLiteral(outfile, level, name_='CNetwork')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('connectome_surface=[\n')
        level += 1
        for connectome_surface_ in self.connectome_surface:
            showIndent(outfile, level)
            outfile.write('model_.CSurface(\n')
            connectome_surface_.exportLiteral(outfile, level, name_='CSurface')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('connectome_volume=[\n')
        level += 1
        for connectome_volume_ in self.connectome_volume:
            showIndent(outfile, level)
            outfile.write('model_.CVolume(\n')
            connectome_volume_.exportLiteral(outfile, level, name_='CVolume')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('connectome_track=[\n')
        level += 1
        for connectome_track_ in self.connectome_track:
            showIndent(outfile, level)
            outfile.write('model_.CTrack(\n')
            connectome_track_.exportLiteral(outfile, level, name_='CTrack')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('connectome_timeserie=[\n')
        level += 1
        for connectome_timeserie_ in self.connectome_timeserie:
            showIndent(outfile, level)
            outfile.write('model_.CTimeserie(\n')
            connectome_timeserie_.exportLiteral(outfile, level, name_='CTimeserie')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('connectome_data=[\n')
        level += 1
        for connectome_data_ in self.connectome_data:
            showIndent(outfile, level)
            outfile.write('model_.CData(\n')
            connectome_data_.exportLiteral(outfile, level, name_='CData')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('connectome_script=[\n')
        level += 1
        for connectome_script_ in self.connectome_script:
            showIndent(outfile, level)
            outfile.write('model_.CScript(\n')
            connectome_script_.exportLiteral(outfile, level, name_='CScript')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('connectome_imagestack=[\n')
        level += 1
        for connectome_imagestack_ in self.connectome_imagestack:
            showIndent(outfile, level)
            outfile.write('model_.CImagestack(\n')
            connectome_imagestack_.exportLiteral(outfile, level, name_='CImagestack')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'connectome-meta': 
            obj_ = CMetadata.factory()
            obj_.build(child_)
            self.set_connectome_meta(obj_)
        elif nodeName_ == 'connectome-network': 
            obj_ = CNetwork.factory()
            obj_.build(child_)
            self.connectome_network.append(obj_)
        elif nodeName_ == 'connectome-surface': 
            obj_ = CSurface.factory()
            obj_.build(child_)
            self.connectome_surface.append(obj_)
        elif nodeName_ == 'connectome-volume': 
            obj_ = CVolume.factory()
            obj_.build(child_)
            self.connectome_volume.append(obj_)
        elif nodeName_ == 'connectome-track': 
            obj_ = CTrack.factory()
            obj_.build(child_)
            self.connectome_track.append(obj_)
        elif nodeName_ == 'connectome-timeserie': 
            obj_ = CTimeserie.factory()
            obj_.build(child_)
            self.connectome_timeserie.append(obj_)
        elif nodeName_ == 'connectome-data': 
            obj_ = CData.factory()
            obj_.build(child_)
            self.connectome_data.append(obj_)
        elif nodeName_ == 'connectome-script': 
            obj_ = CScript.factory()
            obj_.build(child_)
            self.connectome_script.append(obj_)
        elif nodeName_ == 'connectome-imagestack': 
            obj_ = CImagestack.factory()
            obj_.build(child_)
            self.connectome_imagestack.append(obj_)
# end class connectome


class CMetadata(GeneratedsSuper):
    """Defines the version of the Connectome Schema Definition the current
    Connectome File is compatible with. Should be 2.0"""
    subclass = None
    superclass = None
    def __init__(self, version=None, title=None, creator=None, publisher=None, created=None, modified=None, rights=None, license=None, references=None, relation=None, generator=None, species=None, email=None, metadata=None):
        self.version = _cast(None, version)
        self.title = title
        self.creator = creator
        self.publisher = publisher
        self.created = created
        self.modified = modified
        self.rights = rights
        self.license = license
        self.references = references
        self.relation = relation
        self.modified = modified
        self.generator = generator
        self.species = species
        self.email = email
        self.metadata = metadata
    def factory(*args_, **kwargs_):
        if CMetadata.subclass:
            return CMetadata.subclass(*args_, **kwargs_)
        else:
            return CMetadata(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_creator(self): return self.creator
    def set_creator(self, creator): self.creator = creator
    def get_publisher(self): return self.publisher
    def set_publisher(self, publisher): self.publisher = publisher
    def get_created(self): return self.created
    def set_created(self, created): self.created = created
    def get_modified(self): return self.modified
    def set_modified(self, modified): self.modified = modified
    def get_rights(self): return self.rights
    def set_rights(self, rights): self.rights = rights
    def get_license(self): return self.license
    def set_license(self, license): self.license = license
    def get_references(self): return self.references
    def set_references(self, references): self.references = references
    def get_relation(self): return self.relation
    def set_relation(self, relation): self.relation = relation
    def get_modified(self): return self.modified
    def set_modified(self, modified): self.modified = modified
    def get_generator(self): return self.generator
    def set_generator(self, generator): self.generator = generator
    def get_species(self): return self.species
    def set_species(self, species): self.species = species
    def get_email(self): return self.email
    def set_email(self, email): self.email = email
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def export(self, outfile, level, namespace_='', name_='CMetadata', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='CMetadata')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CMetadata'):
        outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CMetadata'):
        if self.title is not None:
            showIndent(outfile, level)
            outfile.write('<%stitle>%s</%stitle>\n' % (namespace_, self.gds_format_string(quote_xml(self.title).encode(ExternalEncoding), input_name='title'), namespace_))
        if self.creator is not None:
            showIndent(outfile, level)
            outfile.write('<%screator>%s</%screator>\n' % (namespace_, self.gds_format_string(quote_xml(self.creator).encode(ExternalEncoding), input_name='creator'), namespace_))
        if self.publisher is not None:
            showIndent(outfile, level)
            outfile.write('<%spublisher>%s</%spublisher>\n' % (namespace_, self.gds_format_string(quote_xml(self.publisher).encode(ExternalEncoding), input_name='publisher'), namespace_))
        if self.created is not None:
            showIndent(outfile, level)
            outfile.write('<%screated>%s</%screated>\n' % (namespace_, self.gds_format_string(quote_xml(self.created).encode(ExternalEncoding), input_name='created'), namespace_))
        if self.modified is not None:
            showIndent(outfile, level)
            outfile.write('<%smodified>%s</%smodified>\n' % (namespace_, self.gds_format_string(quote_xml(self.modified).encode(ExternalEncoding), input_name='modified'), namespace_))
        if self.rights is not None:
            showIndent(outfile, level)
            outfile.write('<%srights>%s</%srights>\n' % (namespace_, self.gds_format_string(quote_xml(self.rights).encode(ExternalEncoding), input_name='rights'), namespace_))
        if self.license is not None:
            showIndent(outfile, level)
            outfile.write('<%slicense>%s</%slicense>\n' % (namespace_, self.gds_format_string(quote_xml(self.license).encode(ExternalEncoding), input_name='license'), namespace_))
        if self.references is not None:
            showIndent(outfile, level)
            outfile.write('<%sreferences>%s</%sreferences>\n' % (namespace_, self.gds_format_string(quote_xml(self.references).encode(ExternalEncoding), input_name='references'), namespace_))
        if self.relation is not None:
            showIndent(outfile, level)
            outfile.write('<%srelation>%s</%srelation>\n' % (namespace_, self.gds_format_string(quote_xml(self.relation).encode(ExternalEncoding), input_name='relation'), namespace_))
        if self.modified is not None:
            showIndent(outfile, level)
            outfile.write('<%smodified>%s</%smodified>\n' % (namespace_, self.gds_format_string(quote_xml(self.modified).encode(ExternalEncoding), input_name='modified'), namespace_))
        if self.generator is not None:
            showIndent(outfile, level)
            outfile.write('<%sgenerator>%s</%sgenerator>\n' % (namespace_, self.gds_format_string(quote_xml(self.generator).encode(ExternalEncoding), input_name='generator'), namespace_))
        if self.species is not None:
            showIndent(outfile, level)
            outfile.write('<%sspecies>%s</%sspecies>\n' % (namespace_, self.gds_format_string(quote_xml(self.species).encode(ExternalEncoding), input_name='species'), namespace_))
        if self.email is not None:
            showIndent(outfile, level)
            outfile.write('<%semail>%s</%semail>\n' % (namespace_, self.gds_format_string(quote_xml(self.email).encode(ExternalEncoding), input_name='email'), namespace_))
        if self.metadata:
            self.metadata.export(outfile, level, namespace_, name_='metadata')
    def hasContent_(self):
        if (
            self.title is not None or
            self.creator is not None or
            self.publisher is not None or
            self.created is not None or
            self.modified is not None or
            self.rights is not None or
            self.license is not None or
            self.references is not None or
            self.relation is not None or
            self.modified is not None or
            self.generator is not None or
            self.species is not None or
            self.email is not None or
            self.metadata is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CMetadata'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            showIndent(outfile, level)
            outfile.write('version = "%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.title is not None:
            showIndent(outfile, level)
            outfile.write('title=%s,\n' % quote_python(self.title).encode(ExternalEncoding))
        if self.creator is not None:
            showIndent(outfile, level)
            outfile.write('creator=%s,\n' % quote_python(self.creator).encode(ExternalEncoding))
        if self.publisher is not None:
            showIndent(outfile, level)
            outfile.write('publisher=%s,\n' % quote_python(self.publisher).encode(ExternalEncoding))
        if self.created is not None:
            showIndent(outfile, level)
            outfile.write('created=%s,\n' % quote_python(self.created).encode(ExternalEncoding))
        if self.modified is not None:
            showIndent(outfile, level)
            outfile.write('modified=%s,\n' % quote_python(self.modified).encode(ExternalEncoding))
        if self.rights is not None:
            showIndent(outfile, level)
            outfile.write('rights=%s,\n' % quote_python(self.rights).encode(ExternalEncoding))
        if self.license is not None:
            showIndent(outfile, level)
            outfile.write('license=%s,\n' % quote_python(self.license).encode(ExternalEncoding))
        if self.references is not None:
            showIndent(outfile, level)
            outfile.write('references=%s,\n' % quote_python(self.references).encode(ExternalEncoding))
        if self.relation is not None:
            showIndent(outfile, level)
            outfile.write('relation=%s,\n' % quote_python(self.relation).encode(ExternalEncoding))
        if self.modified is not None:
            showIndent(outfile, level)
            outfile.write('modified=%s,\n' % quote_python(self.modified).encode(ExternalEncoding))
        if self.generator is not None:
            showIndent(outfile, level)
            outfile.write('generator=%s,\n' % quote_python(self.generator).encode(ExternalEncoding))
        if self.species is not None:
            showIndent(outfile, level)
            outfile.write('species=%s,\n' % quote_python(self.species).encode(ExternalEncoding))
        if self.email is not None:
            showIndent(outfile, level)
            outfile.write('email=%s,\n' % quote_python(self.email).encode(ExternalEncoding))
        if self.metadata is not None:
            showIndent(outfile, level)
            outfile.write('metadata=model_.Metadata(\n')
            self.metadata.exportLiteral(outfile, level, name_='metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('version')
        if value is not None and 'version' not in already_processed:
            already_processed.append('version')
            self.version = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'title':
            title_ = child_.text
            self.title = title_
        elif nodeName_ == 'creator':
            creator_ = child_.text
            self.creator = creator_
        elif nodeName_ == 'publisher':
            publisher_ = child_.text
            self.publisher = publisher_
        elif nodeName_ == 'created':
            created_ = child_.text
            self.created = created_
        elif nodeName_ == 'modified':
            modified_ = child_.text
            self.modified = modified_
        elif nodeName_ == 'rights':
            rights_ = child_.text
            self.rights = rights_
        elif nodeName_ == 'license':
            license_ = child_.text
            self.license = license_
        elif nodeName_ == 'references':
            references_ = child_.text
            self.references = references_
        elif nodeName_ == 'relation':
            relation_ = child_.text
            self.relation = relation_
        elif nodeName_ == 'modified':
            modified_ = child_.text
            self.modified = modified_
        elif nodeName_ == 'generator':
            generator_ = child_.text
            self.generator = generator_
        elif nodeName_ == 'species':
            species_ = child_.text
            self.species = species_
        elif nodeName_ == 'email':
            email_ = child_.text
            self.email = email_
        elif nodeName_ == 'metadata': 
            obj_ = Metadata.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
# end class CMetadata


class CNetwork(GeneratedsSuper):
    """The short name of the network The path to the file according to
    location attribute Is the network stored it "GEXF" or "GraphML"
    format, "NXGPickle" as NetworkX pickled object, or "Other"
    format? - dtype="AttributeNetwork" A network with arbitrary
    number of attributes for nodes and edges. -
    dtype="DynamicNetwork" Network with either with lifespan
    attributes for nodes and edges (See GEXF) or timeseries on nodes
    and edges. - dtype="HierarchicalNetwork" Network with
    hierarchical structure. - dtype="StructuralNetwork" A structural
    network e.g. derived from Diffusion MRI -
    dtype="FunctionalNetwork" Networks derived from functional
    measures such as EEG/MEG/fMRI/PET etc. -
    dtype="EffectiveNetwork" Networks representing effective
    connectivities - dtype="Other" Other kind of network."""
    subclass = None
    superclass = None
    def __init__(self, src=None, dtype='AttributeNetwork', name=None, fileformat='GraphML', metadata=None, description=None):
        self.src = _cast(None, src)
        self.dtype = _cast(None, dtype)
        self.name = _cast(None, name)
        self.fileformat = _cast(None, fileformat)
        self.metadata = metadata
        self.description = description
    def factory(*args_, **kwargs_):
        if CNetwork.subclass:
            return CNetwork.subclass(*args_, **kwargs_)
        else:
            return CNetwork(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_src(self): return self.src
    def set_src(self, src): self.src = src
    def get_dtype(self): return self.dtype
    def set_dtype(self, dtype): self.dtype = dtype
    def validate_networkEnumDType(self, value):
        # Validate type networkEnumDType, a restriction on xsd:string.
        pass
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_fileformat(self): return self.fileformat
    def set_fileformat(self, fileformat): self.fileformat = fileformat
    def validate_networkFileFormat(self, value):
        # Validate type networkFileFormat, a restriction on xsd:string.
        pass
    def export(self, outfile, level, namespace_='', name_='CNetwork', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='CNetwork')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CNetwork'):
        if self.src is not None and 'src' not in already_processed:
            already_processed.append('src')
            outfile.write(' src=%s' % (self.gds_format_string(quote_attrib(self.src).encode(ExternalEncoding), input_name='src'), ))
        if self.dtype is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            outfile.write(' dtype=%s' % (quote_attrib(self.dtype), ))
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.fileformat is not None and 'fileformat' not in already_processed:
            already_processed.append('fileformat')
            outfile.write(' fileformat=%s' % (quote_attrib(self.fileformat), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CNetwork'):
        if self.metadata:
            self.metadata.export(outfile, level, namespace_, name_='metadata')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
    def hasContent_(self):
        if (
            self.metadata is not None or
            self.description is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CNetwork'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.src is not None and 'src' not in already_processed:
            already_processed.append('src')
            showIndent(outfile, level)
            outfile.write('src = "%s",\n' % (self.src,))
        if self.dtype is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            showIndent(outfile, level)
            outfile.write('dtype = "%s",\n' % (self.dtype,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.fileformat is not None and 'fileformat' not in already_processed:
            already_processed.append('fileformat')
            showIndent(outfile, level)
            outfile.write('fileformat = "%s",\n' % (self.fileformat,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.metadata is not None:
            showIndent(outfile, level)
            outfile.write('metadata=model_.Metadata(\n')
            self.metadata.exportLiteral(outfile, level, name_='metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('src')
        if value is not None and 'src' not in already_processed:
            already_processed.append('src')
            self.src = value
        value = attrs.get('dtype')
        if value is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            self.dtype = value
        value = attrs.get('name')
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = attrs.get('fileformat')
        if value is not None and 'fileformat' not in already_processed:
            already_processed.append('fileformat')
            self.fileformat = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'metadata': 
            obj_ = Metadata.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
        elif nodeName_ == 'description':
            description_ = child_.text
            self.description = description_
# end class CNetwork


class CSurface(GeneratedsSuper):
    """Descriptive name of the surface. The path to the file according to
    location attribute Set to "gifti" to use the only supported
    Gifti format by cfflib. See
    http://www.nitrc.org/frs/download.php/158/gifti.xsd for schema
    information Use "Other" for other formats with custom IO
    Handling What type of surface does the Gifti file contain: -
    type="Labeling" The Gifti file contains surface labels. This
    file can be referenced in connectome-network with either the
    name attribute or in addition to another surface defined by name
    and using the labelname attribute and matching labelid. If
    referenced in such a way, the networks' nodes attribute
    dn_intensityvalue value may match the label array integers,
    thereby relating a network node to a surface patch (a region of
    interest defined on the surface). See also example datasets. -
    type="Surfaceset" The Gifti file contains a set of surfaces
    where the metadata tag AnatomicalStructurePrimary match.
    Individual elements of the set are distinguished by the metadta
    tag AnatomicalStructureSecondary. The Gifti file contains
    information about the coordinate system used. -
    type="Surfaceset+Labeling" If the Gifti file contains data as
    described for both surfaceset and label above. - type="Other"
    Any other kind of data storable in a Gifti file."""
    subclass = None
    superclass = None
    def __init__(self, src=None, dtype='Surfaceset', name=None, fileformat=None, description=None, metadata=None):
        self.src = _cast(None, src)
        self.dtype = _cast(None, dtype)
        self.name = _cast(None, name)
        self.fileformat = _cast(None, fileformat)
        self.description = description
        self.metadata = metadata
    def factory(*args_, **kwargs_):
        if CSurface.subclass:
            return CSurface.subclass(*args_, **kwargs_)
        else:
            return CSurface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    def get_src(self): return self.src
    def set_src(self, src): self.src = src
    def get_dtype(self): return self.dtype
    def set_dtype(self, dtype): self.dtype = dtype
    def validate_surfaceEnumDType(self, value):
        # Validate type surfaceEnumDType, a restriction on xsd:string.
        pass
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_fileformat(self): return self.fileformat
    def set_fileformat(self, fileformat): self.fileformat = fileformat
    def validate_surfaceFileFormat(self, value):
        # Validate type surfaceFileFormat, a restriction on xsd:string.
        pass
    def export(self, outfile, level, namespace_='', name_='CSurface', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='CSurface')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CSurface'):
        if self.src is not None and 'src' not in already_processed:
            already_processed.append('src')
            outfile.write(' src=%s' % (self.gds_format_string(quote_attrib(self.src).encode(ExternalEncoding), input_name='src'), ))
        if self.dtype is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            outfile.write(' dtype=%s' % (quote_attrib(self.dtype), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.fileformat is not None and 'fileformat' not in already_processed:
            already_processed.append('fileformat')
            outfile.write(' fileformat=%s' % (quote_attrib(self.fileformat), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CSurface'):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        if self.metadata:
            self.metadata.export(outfile, level, namespace_, name_='metadata', )
    def hasContent_(self):
        if (
            self.description is not None or
            self.metadata is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CSurface'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.src is not None and 'src' not in already_processed:
            already_processed.append('src')
            showIndent(outfile, level)
            outfile.write('src = "%s",\n' % (self.src,))
        if self.dtype is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            showIndent(outfile, level)
            outfile.write('dtype = "%s",\n' % (self.dtype,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.fileformat is not None and 'fileformat' not in already_processed:
            already_processed.append('fileformat')
            showIndent(outfile, level)
            outfile.write('fileformat = "%s",\n' % (self.fileformat,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.metadata is not None:
            showIndent(outfile, level)
            outfile.write('metadata=model_.Metadata(\n')
            self.metadata.exportLiteral(outfile, level, name_='metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('src')
        if value is not None and 'src' not in already_processed:
            already_processed.append('src')
            self.src = value
        value = attrs.get('dtype')
        if value is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            self.dtype = value
        value = attrs.get('name')
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = attrs.get('fileformat')
        if value is not None and 'fileformat' not in already_processed:
            already_processed.append('fileformat')
            self.fileformat = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'description':
            description_ = child_.text
            self.description = description_
        elif nodeName_ == 'metadata': 
            obj_ = Metadata.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
# end class CSurface


class CVolume(GeneratedsSuper):
    """Name of the volume. The path to the file according to location
    attribute Set to "Nifti1" to use the only supported Nifti
    format. This works also for compressed files with name ending
    .nii.gz The Nifti file contains information about the coordinate
    system used. Set type of volume the Nifti file contains: -
    type="Segmentation" The Nifti file contains a single volume
    where the voxel values are integers, representing a segmented
    Region of Interest. If this volume is referenced by a
    connectome-network, its nodes dn_intensityvalue attribute may
    match these integer values. Such a segmentation volume can
    referenced in a connectome-volume by the segmentationname
    attribute in addition to another, e.g. T1-weighted volume which
    is referenced by the name attribute. See also example datasets.
    - type="T1-weighted" The Nifti file contains a T1-weighted
    volume. - type="T2-weighted" The Nifti file contains a
    T2-weighted volume. - type="PD-weighted" The voxel values
    represent a proton-density weighted signal. - type="fMRI" The
    Nifti file contains functional MRI time series data. -
    type="Probabilitymap" Voxel values are in the range [0,1]. Can
    stand for tissue probability maps. - type="MD" Diffusion-related
    signal. Stands for mean diffusivity. - type="FA" Diffusion-
    related signal. Stands for fractional anisotropy. - type="LD"
    Diffusion-related signal. Stands for longitudinal diffusivity. -
    type="TD" Diffusion-related signal. Stands for transversal
    diffusivity. - type="FLAIR" Stands for Fluid attenuated
    inversion recovery - type="MRA" Stands for Magnetic resonance
    angiography - type="MRS" Stands for Magnetic resonance
    spectroscopy"""
    subclass = None
    superclass = None
    def __init__(self, src=None, dtype=None, name=None, fileformat='Nifti1', description=None, metadata=None):
        self.src = _cast(None, src)
        self.dtype = _cast(None, dtype)
        self.name = _cast(None, name)
        self.fileformat = _cast(None, fileformat)
        self.description = description
        self.metadata = metadata
    def factory(*args_, **kwargs_):
        if CVolume.subclass:
            return CVolume.subclass(*args_, **kwargs_)
        else:
            return CVolume(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    def get_src(self): return self.src
    def set_src(self, src): self.src = src
    def get_dtype(self): return self.dtype
    def set_dtype(self, dtype): self.dtype = dtype
    def validate_volumeEnumDType(self, value):
        # Validate type volumeEnumDType, a restriction on xsd:string.
        pass
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_fileformat(self): return self.fileformat
    def set_fileformat(self, fileformat): self.fileformat = fileformat
    def validate_volumeFileFormat(self, value):
        # Validate type volumeFileFormat, a restriction on xsd:string.
        pass
    def export(self, outfile, level, namespace_='', name_='CVolume', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='CVolume')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CVolume'):
        if self.src is not None and 'src' not in already_processed:
            already_processed.append('src')
            outfile.write(' src=%s' % (self.gds_format_string(quote_attrib(self.src).encode(ExternalEncoding), input_name='src'), ))
        if self.dtype is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            outfile.write(' dtype=%s' % (quote_attrib(self.dtype), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.fileformat is not None and 'fileformat' not in already_processed:
            already_processed.append('fileformat')
            outfile.write(' fileformat=%s' % (quote_attrib(self.fileformat), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CVolume'):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        if self.metadata:
            self.metadata.export(outfile, level, namespace_, name_='metadata', )
    def hasContent_(self):
        if (
            self.description is not None or
            self.metadata is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CVolume'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.src is not None and 'src' not in already_processed:
            already_processed.append('src')
            showIndent(outfile, level)
            outfile.write('src = "%s",\n' % (self.src,))
        if self.dtype is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            showIndent(outfile, level)
            outfile.write('dtype = "%s",\n' % (self.dtype,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.fileformat is not None and 'fileformat' not in already_processed:
            already_processed.append('fileformat')
            showIndent(outfile, level)
            outfile.write('fileformat = "%s",\n' % (self.fileformat,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.metadata is not None:
            showIndent(outfile, level)
            outfile.write('metadata=model_.Metadata(\n')
            self.metadata.exportLiteral(outfile, level, name_='metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('src')
        if value is not None and 'src' not in already_processed:
            already_processed.append('src')
            self.src = value
        value = attrs.get('dtype')
        if value is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            self.dtype = value
        value = attrs.get('name')
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = attrs.get('fileformat')
        if value is not None and 'fileformat' not in already_processed:
            already_processed.append('fileformat')
            self.fileformat = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'description':
            description_ = child_.text
            self.description = description_
        elif nodeName_ == 'metadata': 
            obj_ = Metadata.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
# end class CVolume


class CTrack(GeneratedsSuper):
    """Name of the track file. The path to the file according to location
    attribute Set to "TrackVis" (default) to use the only supported
    TrackVis file format. The TrackVis file format allows to store
    any number of additional numerical data on the individual
    fibers."""
    subclass = None
    superclass = None
    def __init__(self, src=None, dtype=None, name=None, fileformat='TrackVis', description=None, metadata=None):
        self.src = _cast(None, src)
        self.dtype = _cast(None, dtype)
        self.name = _cast(None, name)
        self.fileformat = _cast(None, fileformat)
        self.description = description
        self.metadata = metadata
    def factory(*args_, **kwargs_):
        if CTrack.subclass:
            return CTrack.subclass(*args_, **kwargs_)
        else:
            return CTrack(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    def get_src(self): return self.src
    def set_src(self, src): self.src = src
    def get_dtype(self): return self.dtype
    def set_dtype(self, dtype): self.dtype = dtype
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_fileformat(self): return self.fileformat
    def set_fileformat(self, fileformat): self.fileformat = fileformat
    def validate_trackFileFormat(self, value):
        # Validate type trackFileFormat, a restriction on xsd:string.
        pass
    def export(self, outfile, level, namespace_='', name_='CTrack', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='CTrack')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CTrack'):
        if self.src is not None and 'src' not in already_processed:
            already_processed.append('src')
            outfile.write(' src=%s' % (self.gds_format_string(quote_attrib(self.src).encode(ExternalEncoding), input_name='src'), ))
        if self.dtype is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            outfile.write(' dtype=%s' % (self.gds_format_string(quote_attrib(self.dtype).encode(ExternalEncoding), input_name='dtype'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.fileformat is not None and 'fileformat' not in already_processed:
            already_processed.append('fileformat')
            outfile.write(' fileformat=%s' % (quote_attrib(self.fileformat), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CTrack'):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        if self.metadata:
            self.metadata.export(outfile, level, namespace_, name_='metadata', )
    def hasContent_(self):
        if (
            self.description is not None or
            self.metadata is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CTrack'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.src is not None and 'src' not in already_processed:
            already_processed.append('src')
            showIndent(outfile, level)
            outfile.write('src = "%s",\n' % (self.src,))
        if self.dtype is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            showIndent(outfile, level)
            outfile.write('dtype = "%s",\n' % (self.dtype,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.fileformat is not None and 'fileformat' not in already_processed:
            already_processed.append('fileformat')
            showIndent(outfile, level)
            outfile.write('fileformat = "%s",\n' % (self.fileformat,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.metadata is not None:
            showIndent(outfile, level)
            outfile.write('metadata=model_.Metadata(\n')
            self.metadata.exportLiteral(outfile, level, name_='metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('src')
        if value is not None and 'src' not in already_processed:
            already_processed.append('src')
            self.src = value
        value = attrs.get('dtype')
        if value is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            self.dtype = value
        value = attrs.get('name')
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = attrs.get('fileformat')
        if value is not None and 'fileformat' not in already_processed:
            already_processed.append('fileformat')
            self.fileformat = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'description':
            description_ = child_.text
            self.description = description_
        elif nodeName_ == 'metadata': 
            obj_ = Metadata.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
# end class CTrack


class CTimeserie(GeneratedsSuper):
    """Name of the timeseries. The path to the file according to location
    attribute Set to "HDF5" (default) to use the only supported
    Hierarchical Data File format. The HDF5 allows to store any
    number of time series or other large homogeneous data."""
    subclass = None
    superclass = None
    def __init__(self, src=None, dtype=None, name=None, fileformat='HDF5', description=None, metadata=None):
        self.src = _cast(None, src)
        self.dtype = _cast(None, dtype)
        self.name = _cast(None, name)
        self.fileformat = _cast(None, fileformat)
        self.description = description
        self.metadata = metadata
    def factory(*args_, **kwargs_):
        if CTimeserie.subclass:
            return CTimeserie.subclass(*args_, **kwargs_)
        else:
            return CTimeserie(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    def get_src(self): return self.src
    def set_src(self, src): self.src = src
    def get_dtype(self): return self.dtype
    def set_dtype(self, dtype): self.dtype = dtype
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_fileformat(self): return self.fileformat
    def set_fileformat(self, fileformat): self.fileformat = fileformat
    def validate_timeserieFileFormat(self, value):
        # Validate type timeserieFileFormat, a restriction on xsd:string.
        pass
    def export(self, outfile, level, namespace_='', name_='CTimeserie', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='CTimeserie')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CTimeserie'):
        if self.src is not None and 'src' not in already_processed:
            already_processed.append('src')
            outfile.write(' src=%s' % (self.gds_format_string(quote_attrib(self.src).encode(ExternalEncoding), input_name='src'), ))
        if self.dtype is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            outfile.write(' dtype=%s' % (self.gds_format_string(quote_attrib(self.dtype).encode(ExternalEncoding), input_name='dtype'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.fileformat is not None and 'fileformat' not in already_processed:
            already_processed.append('fileformat')
            outfile.write(' fileformat=%s' % (quote_attrib(self.fileformat), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CTimeserie'):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        if self.metadata:
            self.metadata.export(outfile, level, namespace_, name_='metadata', )
    def hasContent_(self):
        if (
            self.description is not None or
            self.metadata is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CTimeserie'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.src is not None and 'src' not in already_processed:
            already_processed.append('src')
            showIndent(outfile, level)
            outfile.write('src = "%s",\n' % (self.src,))
        if self.dtype is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            showIndent(outfile, level)
            outfile.write('dtype = "%s",\n' % (self.dtype,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.fileformat is not None and 'fileformat' not in already_processed:
            already_processed.append('fileformat')
            showIndent(outfile, level)
            outfile.write('fileformat = "%s",\n' % (self.fileformat,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.metadata is not None:
            showIndent(outfile, level)
            outfile.write('metadata=model_.Metadata(\n')
            self.metadata.exportLiteral(outfile, level, name_='metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('src')
        if value is not None and 'src' not in already_processed:
            already_processed.append('src')
            self.src = value
        value = attrs.get('dtype')
        if value is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            self.dtype = value
        value = attrs.get('name')
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = attrs.get('fileformat')
        if value is not None and 'fileformat' not in already_processed:
            already_processed.append('fileformat')
            self.fileformat = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'description':
            description_ = child_.text
            self.description = description_
        elif nodeName_ == 'metadata': 
            obj_ = Metadata.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
# end class CTimeserie


class CData(GeneratedsSuper):
    """Name of the data file The path to the file according to location
    attribute Use one of 'NumPy', 'HDF5', 'XML', 'Other'"""
    subclass = None
    superclass = None
    def __init__(self, src=None, dtype=None, name=None, fileformat=None, description=None, metadata=None):
        self.src = _cast(None, src)
        self.dtype = _cast(None, dtype)
        self.name = _cast(None, name)
        self.fileformat = _cast(None, fileformat)
        self.description = description
        self.metadata = metadata
    def factory(*args_, **kwargs_):
        if CData.subclass:
            return CData.subclass(*args_, **kwargs_)
        else:
            return CData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    def get_src(self): return self.src
    def set_src(self, src): self.src = src
    def get_dtype(self): return self.dtype
    def set_dtype(self, dtype): self.dtype = dtype
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_fileformat(self): return self.fileformat
    def set_fileformat(self, fileformat): self.fileformat = fileformat
    def validate_dataFileFormat(self, value):
        # Validate type dataFileFormat, a restriction on xsd:string.
        pass
    def export(self, outfile, level, namespace_='', name_='CData', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='CData')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CData'):
        if self.src is not None and 'src' not in already_processed:
            already_processed.append('src')
            outfile.write(' src=%s' % (self.gds_format_string(quote_attrib(self.src).encode(ExternalEncoding), input_name='src'), ))
        if self.dtype is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            outfile.write(' dtype=%s' % (self.gds_format_string(quote_attrib(self.dtype).encode(ExternalEncoding), input_name='dtype'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.fileformat is not None and 'fileformat' not in already_processed:
            already_processed.append('fileformat')
            outfile.write(' fileformat=%s' % (quote_attrib(self.fileformat), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CData'):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        if self.metadata:
            self.metadata.export(outfile, level, namespace_, name_='metadata', )
    def hasContent_(self):
        if (
            self.description is not None or
            self.metadata is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CData'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.src is not None and 'src' not in already_processed:
            already_processed.append('src')
            showIndent(outfile, level)
            outfile.write('src = "%s",\n' % (self.src,))
        if self.dtype is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            showIndent(outfile, level)
            outfile.write('dtype = "%s",\n' % (self.dtype,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.fileformat is not None and 'fileformat' not in already_processed:
            already_processed.append('fileformat')
            showIndent(outfile, level)
            outfile.write('fileformat = "%s",\n' % (self.fileformat,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.metadata is not None:
            showIndent(outfile, level)
            outfile.write('metadata=model_.Metadata(\n')
            self.metadata.exportLiteral(outfile, level, name_='metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('src')
        if value is not None and 'src' not in already_processed:
            already_processed.append('src')
            self.src = value
        value = attrs.get('dtype')
        if value is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            self.dtype = value
        value = attrs.get('name')
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = attrs.get('fileformat')
        if value is not None and 'fileformat' not in already_processed:
            already_processed.append('fileformat')
            self.fileformat = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'description':
            description_ = child_.text
            self.description = description_
        elif nodeName_ == 'metadata': 
            obj_ = Metadata.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
# end class CData


class CScript(GeneratedsSuper):
    """Name of the script file The path to the file according to location
    attribute What kind of script. Use one of "Python" (default),
    "Bash", "Matlab", or "Other"."""
    subclass = None
    superclass = None
    def __init__(self, src=None, dtype='Python', name=None, fileformat='UTF-8', description=None, metadata=None):
        self.src = _cast(None, src)
        self.dtype = _cast(None, dtype)
        self.name = _cast(None, name)
        self.fileformat = _cast(None, fileformat)
        self.description = description
        self.metadata = metadata
    def factory(*args_, **kwargs_):
        if CScript.subclass:
            return CScript.subclass(*args_, **kwargs_)
        else:
            return CScript(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    def get_src(self): return self.src
    def set_src(self, src): self.src = src
    def get_dtype(self): return self.dtype
    def set_dtype(self, dtype): self.dtype = dtype
    def validate_scriptEnumType(self, value):
        # Validate type scriptEnumType, a restriction on xsd:string.
        pass
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_fileformat(self): return self.fileformat
    def set_fileformat(self, fileformat): self.fileformat = fileformat
    def validate_scriptFileFormat(self, value):
        # Validate type scriptFileFormat, a restriction on xsd:string.
        pass
    def export(self, outfile, level, namespace_='', name_='CScript', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='CScript')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CScript'):
        if self.src is not None and 'src' not in already_processed:
            already_processed.append('src')
            outfile.write(' src=%s' % (self.gds_format_string(quote_attrib(self.src).encode(ExternalEncoding), input_name='src'), ))
        if self.dtype is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            outfile.write(' dtype=%s' % (quote_attrib(self.dtype), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.fileformat is not None and 'fileformat' not in already_processed:
            already_processed.append('fileformat')
            outfile.write(' fileformat=%s' % (quote_attrib(self.fileformat), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CScript'):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        if self.metadata:
            self.metadata.export(outfile, level, namespace_, name_='metadata', )
    def hasContent_(self):
        if (
            self.description is not None or
            self.metadata is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CScript'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.src is not None and 'src' not in already_processed:
            already_processed.append('src')
            showIndent(outfile, level)
            outfile.write('src = "%s",\n' % (self.src,))
        if self.dtype is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            showIndent(outfile, level)
            outfile.write('dtype = "%s",\n' % (self.dtype,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.fileformat is not None and 'fileformat' not in already_processed:
            already_processed.append('fileformat')
            showIndent(outfile, level)
            outfile.write('fileformat = "%s",\n' % (self.fileformat,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.metadata is not None:
            showIndent(outfile, level)
            outfile.write('metadata=model_.Metadata(\n')
            self.metadata.exportLiteral(outfile, level, name_='metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('src')
        if value is not None and 'src' not in already_processed:
            already_processed.append('src')
            self.src = value
        value = attrs.get('dtype')
        if value is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            self.dtype = value
        value = attrs.get('name')
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = attrs.get('fileformat')
        if value is not None and 'fileformat' not in already_processed:
            already_processed.append('fileformat')
            self.fileformat = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'description':
            description_ = child_.text
            self.description = description_
        elif nodeName_ == 'metadata': 
            obj_ = Metadata.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
# end class CScript


class CImagestack(GeneratedsSuper):
    """Name of the image stack The path to the enumerated files according
    to location attribute The file name pattern that may contain
    simple shell-style wildcards a la fnmatch. Use one of 'PNG',
    'JPG', 'TIFF', 'Other'"""
    subclass = None
    superclass = None
    def __init__(self, src=None, fileformat=None, name=None, pattern=None, description=None, metadata=None):
        self.src = _cast(None, src)
        self.fileformat = _cast(None, fileformat)
        self.name = _cast(None, name)
        self.pattern = _cast(None, pattern)
        self.description = description
        self.metadata = metadata
    def factory(*args_, **kwargs_):
        if CImagestack.subclass:
            return CImagestack.subclass(*args_, **kwargs_)
        else:
            return CImagestack(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    def get_src(self): return self.src
    def set_src(self, src): self.src = src
    def get_fileformat(self): return self.fileformat
    def set_fileformat(self, fileformat): self.fileformat = fileformat
    def validate_imagestackFileFormat(self, value):
        # Validate type imagestackFileFormat, a restriction on xsd:string.
        pass
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_pattern(self): return self.pattern
    def set_pattern(self, pattern): self.pattern = pattern
    def export(self, outfile, level, namespace_='', name_='CImagestack', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='CImagestack')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CImagestack'):
        if self.src is not None and 'src' not in already_processed:
            already_processed.append('src')
            outfile.write(' src=%s' % (self.gds_format_string(quote_attrib(self.src).encode(ExternalEncoding), input_name='src'), ))
        if self.fileformat is not None and 'fileformat' not in already_processed:
            already_processed.append('fileformat')
            outfile.write(' fileformat=%s' % (quote_attrib(self.fileformat), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.pattern is not None and 'pattern' not in already_processed:
            already_processed.append('pattern')
            outfile.write(' pattern=%s' % (self.gds_format_string(quote_attrib(self.pattern).encode(ExternalEncoding), input_name='pattern'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CImagestack'):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        if self.metadata:
            self.metadata.export(outfile, level, namespace_, name_='metadata', )
    def hasContent_(self):
        if (
            self.description is not None or
            self.metadata is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CImagestack'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.src is not None and 'src' not in already_processed:
            already_processed.append('src')
            showIndent(outfile, level)
            outfile.write('src = "%s",\n' % (self.src,))
        if self.fileformat is not None and 'fileformat' not in already_processed:
            already_processed.append('fileformat')
            showIndent(outfile, level)
            outfile.write('fileformat = "%s",\n' % (self.fileformat,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.pattern is not None and 'pattern' not in already_processed:
            already_processed.append('pattern')
            showIndent(outfile, level)
            outfile.write('pattern = "%s",\n' % (self.pattern,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.metadata is not None:
            showIndent(outfile, level)
            outfile.write('metadata=model_.Metadata(\n')
            self.metadata.exportLiteral(outfile, level, name_='metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('src')
        if value is not None and 'src' not in already_processed:
            already_processed.append('src')
            self.src = value
        value = attrs.get('fileformat')
        if value is not None and 'fileformat' not in already_processed:
            already_processed.append('fileformat')
            self.fileformat = value
        value = attrs.get('name')
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = attrs.get('pattern')
        if value is not None and 'pattern' not in already_processed:
            already_processed.append('pattern')
            self.pattern = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'description':
            description_ = child_.text
            self.description = description_
        elif nodeName_ == 'metadata': 
            obj_ = Metadata.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
# end class CImagestack


class description(GeneratedsSuper):
    """A description according to the format attribute syntax."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if description.subclass:
            return description.subclass(*args_, **kwargs_)
        else:
            return description(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='description', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='description')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='description'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='description'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='description'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class description


class Metadata(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, data=None):
        if data is None:
            self.data = []
        else:
            self.data = data
    def factory(*args_, **kwargs_):
        if Metadata.subclass:
            return Metadata.subclass(*args_, **kwargs_)
        else:
            return Metadata(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_data(self): return self.data
    def set_data(self, data): self.data = data
    def add_data(self, value): self.data.append(value)
    def insert_data(self, index, value): self.data[index] = value
    def export(self, outfile, level, namespace_='', name_='Metadata', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Metadata')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Metadata'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Metadata'):
        for data_ in self.data:
            data_.export(outfile, level, namespace_, name_='data')
    def hasContent_(self):
        if (
            self.data
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Metadata'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('data=[\n')
        level += 1
        for data_ in self.data:
            showIndent(outfile, level)
            outfile.write('model_.data(\n')
            data_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'data': 
            obj_ = data.factory()
            obj_.build(child_)
            self.data.append(obj_)
# end class Metadata


class data(GeneratedsSuper):
    """A data element contains a key attribute and the value as tag The key
    to be used later in the dictionary"""
    subclass = None
    superclass = None
    def __init__(self, key=None, valueOf_=None):
        self.key = _cast(None, key)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if data.subclass:
            return data.subclass(*args_, **kwargs_)
        else:
            return data(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='data', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='data')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='data'):
        if self.key is not None and 'key' not in already_processed:
            already_processed.append('key')
            outfile.write(' key=%s' % (self.gds_format_string(quote_attrib(self.key).encode(ExternalEncoding), input_name='key'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='data'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='data'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.key is not None and 'key' not in already_processed:
            already_processed.append('key')
            showIndent(outfile, level)
            outfile.write('key = "%s",\n' % (self.key,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('key')
        if value is not None and 'key' not in already_processed:
            already_processed.append('key')
            self.key = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class data


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'connectome'
        rootClass = connectome
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag, 
        namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'connectome'
        rootClass = connectome
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="connectome",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'connectome'
        rootClass = connectome
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from cff import *\n\n')
    sys.stdout.write('import cff as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "CData",
    "CImagestack",
    "CMetadata",
    "CNetwork",
    "CScript",
    "CSurface",
    "CTimeserie",
    "CTrack",
    "CVolume",
    "Metadata",
    "connectome",
    "data",
    "description"
    ]
