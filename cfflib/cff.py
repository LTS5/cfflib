#!/usr/bin/env python

#
# Generated Tue Oct 19 09:30:45 2010 by generateDS.py version 2.1a.
#

import sys
import getopt
from string import lower as str_lower
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def format_string(self, input_data, input_name=''):
            return input_data
        def format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def format_boolean(self, input_data, input_name=''):
            return '%s' % input_data


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    text = node.text if node.text is not None else ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class connectome(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, connectome_meta=None, connectome_network=None, connectome_surface=None, connectome_volume=None, connectome_track=None, connectome_timeserie=None, connectome_data=None, connectome_script=None, connectome_imagestack=None):
        self.connectome_meta = connectome_meta
        if connectome_network is None:
            self.connectome_network = []
        else:
            self.connectome_network = connectome_network
        if connectome_surface is None:
            self.connectome_surface = []
        else:
            self.connectome_surface = connectome_surface
        if connectome_volume is None:
            self.connectome_volume = []
        else:
            self.connectome_volume = connectome_volume
        if connectome_track is None:
            self.connectome_track = []
        else:
            self.connectome_track = connectome_track
        if connectome_timeserie is None:
            self.connectome_timeserie = []
        else:
            self.connectome_timeserie = connectome_timeserie
        if connectome_data is None:
            self.connectome_data = []
        else:
            self.connectome_data = connectome_data
        if connectome_script is None:
            self.connectome_script = []
        else:
            self.connectome_script = connectome_script
        if connectome_imagestack is None:
            self.connectome_imagestack = []
        else:
            self.connectome_imagestack = connectome_imagestack
    def factory(*args_, **kwargs_):
        if connectome.subclass:
            return connectome.subclass(*args_, **kwargs_)
        else:
            return connectome(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_connectome_meta(self): return self.connectome_meta
    def set_connectome_meta(self, connectome_meta): self.connectome_meta = connectome_meta
    def get_connectome_network(self): return self.connectome_network
    def set_connectome_network(self, connectome_network): self.connectome_network = connectome_network
    def add_connectome_network(self, value): self.connectome_network.append(value)
    def insert_connectome_network(self, index, value): self.connectome_network[index] = value
    def get_connectome_surface(self): return self.connectome_surface
    def set_connectome_surface(self, connectome_surface): self.connectome_surface = connectome_surface
    def add_connectome_surface(self, value): self.connectome_surface.append(value)
    def insert_connectome_surface(self, index, value): self.connectome_surface[index] = value
    def get_connectome_volume(self): return self.connectome_volume
    def set_connectome_volume(self, connectome_volume): self.connectome_volume = connectome_volume
    def add_connectome_volume(self, value): self.connectome_volume.append(value)
    def insert_connectome_volume(self, index, value): self.connectome_volume[index] = value
    def get_connectome_track(self): return self.connectome_track
    def set_connectome_track(self, connectome_track): self.connectome_track = connectome_track
    def add_connectome_track(self, value): self.connectome_track.append(value)
    def insert_connectome_track(self, index, value): self.connectome_track[index] = value
    def get_connectome_timeserie(self): return self.connectome_timeserie
    def set_connectome_timeserie(self, connectome_timeserie): self.connectome_timeserie = connectome_timeserie
    def add_connectome_timeserie(self, value): self.connectome_timeserie.append(value)
    def insert_connectome_timeserie(self, index, value): self.connectome_timeserie[index] = value
    def get_connectome_data(self): return self.connectome_data
    def set_connectome_data(self, connectome_data): self.connectome_data = connectome_data
    def add_connectome_data(self, value): self.connectome_data.append(value)
    def insert_connectome_data(self, index, value): self.connectome_data[index] = value
    def get_connectome_script(self): return self.connectome_script
    def set_connectome_script(self, connectome_script): self.connectome_script = connectome_script
    def add_connectome_script(self, value): self.connectome_script.append(value)
    def insert_connectome_script(self, index, value): self.connectome_script[index] = value
    def get_connectome_imagestack(self): return self.connectome_imagestack
    def set_connectome_imagestack(self, connectome_imagestack): self.connectome_imagestack = connectome_imagestack
    def add_connectome_imagestack(self, value): self.connectome_imagestack.append(value)
    def insert_connectome_imagestack(self, index, value): self.connectome_imagestack[index] = value
    def export(self, outfile, level, namespace_='', name_='connectome', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='connectome')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='connectome'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='connectome'):
        if self.connectome_meta:
            self.connectome_meta.export(outfile, level, namespace_, name_='connectome-meta', )
        for connectome_network_ in self.connectome_network:
            connectome_network_.export(outfile, level, namespace_, name_='connectome-network')
        for connectome_surface_ in self.connectome_surface:
            connectome_surface_.export(outfile, level, namespace_, name_='connectome-surface')
        for connectome_volume_ in self.connectome_volume:
            connectome_volume_.export(outfile, level, namespace_, name_='connectome-volume')
        for connectome_track_ in self.connectome_track:
            connectome_track_.export(outfile, level, namespace_, name_='connectome-track')
        for connectome_timeserie_ in self.connectome_timeserie:
            connectome_timeserie_.export(outfile, level, namespace_, name_='connectome-timeserie')
        for connectome_data_ in self.connectome_data:
            connectome_data_.export(outfile, level, namespace_, name_='connectome-data')
        for connectome_script_ in self.connectome_script:
            connectome_script_.export(outfile, level, namespace_, name_='connectome-script')
        for connectome_imagestack_ in self.connectome_imagestack:
            connectome_imagestack_.export(outfile, level, namespace_, name_='connectome-imagestack')
    def hasContent_(self):
        if (
            self.connectome_meta is not None or
            self.connectome_network or
            self.connectome_surface or
            self.connectome_volume or
            self.connectome_track or
            self.connectome_timeserie or
            self.connectome_data or
            self.connectome_script or
            self.connectome_imagestack
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='connectome'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.connectome_meta is not None:
            showIndent(outfile, level)
            outfile.write('connectome_meta=model_.CMetadata(\n')
            self.connectome_meta.exportLiteral(outfile, level, name_='connectome_meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('connectome_network=[\n')
        level += 1
        for connectome_network_ in self.connectome_network:
            showIndent(outfile, level)
            outfile.write('model_.CNetwork(\n')
            connectome_network_.exportLiteral(outfile, level, name_='CNetwork')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('connectome_surface=[\n')
        level += 1
        for connectome_surface_ in self.connectome_surface:
            showIndent(outfile, level)
            outfile.write('model_.CSurface(\n')
            connectome_surface_.exportLiteral(outfile, level, name_='CSurface')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('connectome_volume=[\n')
        level += 1
        for connectome_volume_ in self.connectome_volume:
            showIndent(outfile, level)
            outfile.write('model_.CVolume(\n')
            connectome_volume_.exportLiteral(outfile, level, name_='CVolume')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('connectome_track=[\n')
        level += 1
        for connectome_track_ in self.connectome_track:
            showIndent(outfile, level)
            outfile.write('model_.CTrack(\n')
            connectome_track_.exportLiteral(outfile, level, name_='CTrack')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('connectome_timeserie=[\n')
        level += 1
        for connectome_timeserie_ in self.connectome_timeserie:
            showIndent(outfile, level)
            outfile.write('model_.CTimeserie(\n')
            connectome_timeserie_.exportLiteral(outfile, level, name_='CTimeserie')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('connectome_data=[\n')
        level += 1
        for connectome_data_ in self.connectome_data:
            showIndent(outfile, level)
            outfile.write('model_.CData(\n')
            connectome_data_.exportLiteral(outfile, level, name_='CData')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('connectome_script=[\n')
        level += 1
        for connectome_script_ in self.connectome_script:
            showIndent(outfile, level)
            outfile.write('model_.CScript(\n')
            connectome_script_.exportLiteral(outfile, level, name_='CScript')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('connectome_imagestack=[\n')
        level += 1
        for connectome_imagestack_ in self.connectome_imagestack:
            showIndent(outfile, level)
            outfile.write('model_.CImagestack(\n')
            connectome_imagestack_.exportLiteral(outfile, level, name_='CImagestack')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'connectome-meta': 
            obj_ = CMetadata.factory()
            obj_.build(child_)
            self.set_connectome_meta(obj_)
        elif nodeName_ == 'connectome-network': 
            obj_ = CNetwork.factory()
            obj_.build(child_)
            self.connectome_network.append(obj_)
        elif nodeName_ == 'connectome-surface': 
            obj_ = CSurface.factory()
            obj_.build(child_)
            self.connectome_surface.append(obj_)
        elif nodeName_ == 'connectome-volume': 
            obj_ = CVolume.factory()
            obj_.build(child_)
            self.connectome_volume.append(obj_)
        elif nodeName_ == 'connectome-track': 
            obj_ = CTrack.factory()
            obj_.build(child_)
            self.connectome_track.append(obj_)
        elif nodeName_ == 'connectome-timeserie': 
            obj_ = CTimeserie.factory()
            obj_.build(child_)
            self.connectome_timeserie.append(obj_)
        elif nodeName_ == 'connectome-data': 
            obj_ = CData.factory()
            obj_.build(child_)
            self.connectome_data.append(obj_)
        elif nodeName_ == 'connectome-script': 
            obj_ = CScript.factory()
            obj_.build(child_)
            self.connectome_script.append(obj_)
        elif nodeName_ == 'connectome-imagestack': 
            obj_ = CImagestack.factory()
            obj_.build(child_)
            self.connectome_imagestack.append(obj_)
# end class connectome


class CMetadata(GeneratedsSuper):
    """Defines the version of the Connectome Schema Definition the current
    Connectome File is compatible with. Should be 2.0"""
    subclass = None
    superclass = None
    def __init__(self, version=None, generator=None, author=None, institution=None, creation_date=None, modification_date=None, name=None, species=None, legal_notice=None, reference=None, email=None, url=None, description=None, metadata=None):
        self.version = _cast(None, version)
        self.generator = generator
        self.author = author
        self.institution = institution
        self.creation_date = creation_date
        self.modification_date = modification_date
        self.name = name
        self.species = species
        self.legal_notice = legal_notice
        self.reference = reference
        self.email = email
        self.url = url
        self.description = description
        self.metadata = metadata
    def factory(*args_, **kwargs_):
        if CMetadata.subclass:
            return CMetadata.subclass(*args_, **kwargs_)
        else:
            return CMetadata(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_generator(self): return self.generator
    def set_generator(self, generator): self.generator = generator
    def get_author(self): return self.author
    def set_author(self, author): self.author = author
    def get_institution(self): return self.institution
    def set_institution(self, institution): self.institution = institution
    def get_creation_date(self): return self.creation_date
    def set_creation_date(self, creation_date): self.creation_date = creation_date
    def get_modification_date(self): return self.modification_date
    def set_modification_date(self, modification_date): self.modification_date = modification_date
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_species(self): return self.species
    def set_species(self, species): self.species = species
    def get_legal_notice(self): return self.legal_notice
    def set_legal_notice(self, legal_notice): self.legal_notice = legal_notice
    def get_reference(self): return self.reference
    def set_reference(self, reference): self.reference = reference
    def get_email(self): return self.email
    def set_email(self, email): self.email = email
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def export(self, outfile, level, namespace_='', name_='CMetadata', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='CMetadata')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='CMetadata'):
        outfile.write(' version=%s' % (self.format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CMetadata'):
        if self.generator is not None:
            showIndent(outfile, level)
            outfile.write('<%sgenerator>%s</%sgenerator>\n' % (namespace_, self.format_string(quote_xml(self.generator).encode(ExternalEncoding), input_name='generator'), namespace_))
        if self.author is not None:
            showIndent(outfile, level)
            outfile.write('<%sauthor>%s</%sauthor>\n' % (namespace_, self.format_string(quote_xml(self.author).encode(ExternalEncoding), input_name='author'), namespace_))
        if self.institution is not None:
            showIndent(outfile, level)
            outfile.write('<%sinstitution>%s</%sinstitution>\n' % (namespace_, self.format_string(quote_xml(self.institution).encode(ExternalEncoding), input_name='institution'), namespace_))
        if self.creation_date is not None:
            showIndent(outfile, level)
            outfile.write('<%screation-date>%s</%screation-date>\n' % (namespace_, self.format_string(quote_xml(self.creation_date).encode(ExternalEncoding), input_name='creation-date'), namespace_))
        if self.modification_date is not None:
            showIndent(outfile, level)
            outfile.write('<%smodification-date>%s</%smodification-date>\n' % (namespace_, self.format_string(quote_xml(self.modification_date).encode(ExternalEncoding), input_name='modification-date'), namespace_))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('<%sname>%s</%sname>\n' % (namespace_, self.format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_))
        if self.species is not None:
            showIndent(outfile, level)
            outfile.write('<%sspecies>%s</%sspecies>\n' % (namespace_, self.format_string(quote_xml(self.species).encode(ExternalEncoding), input_name='species'), namespace_))
        if self.legal_notice is not None:
            showIndent(outfile, level)
            outfile.write('<%slegal-notice>%s</%slegal-notice>\n' % (namespace_, self.format_string(quote_xml(self.legal_notice).encode(ExternalEncoding), input_name='legal-notice'), namespace_))
        if self.reference is not None:
            showIndent(outfile, level)
            outfile.write('<%sreference>%s</%sreference>\n' % (namespace_, self.format_string(quote_xml(self.reference).encode(ExternalEncoding), input_name='reference'), namespace_))
        if self.email is not None:
            showIndent(outfile, level)
            outfile.write('<%semail>%s</%semail>\n' % (namespace_, self.format_string(quote_xml(self.email).encode(ExternalEncoding), input_name='email'), namespace_))
        if self.url is not None:
            showIndent(outfile, level)
            outfile.write('<%surl>%s</%surl>\n' % (namespace_, self.format_string(quote_xml(self.url).encode(ExternalEncoding), input_name='url'), namespace_))
        if self.description:
            self.description.export(outfile, level, namespace_, name_='description')
        if self.metadata:
            self.metadata.export(outfile, level, namespace_, name_='metadata')
    def hasContent_(self):
        if (
            self.generator is not None or
            self.author is not None or
            self.institution is not None or
            self.creation_date is not None or
            self.modification_date is not None or
            self.name is not None or
            self.species is not None or
            self.legal_notice is not None or
            self.reference is not None or
            self.email is not None or
            self.url is not None or
            self.description is not None or
            self.metadata is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CMetadata'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version = "%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.generator is not None:
            showIndent(outfile, level)
            outfile.write('generator=%s,\n' % quote_python(self.generator).encode(ExternalEncoding))
        if self.author is not None:
            showIndent(outfile, level)
            outfile.write('author=%s,\n' % quote_python(self.author).encode(ExternalEncoding))
        if self.institution is not None:
            showIndent(outfile, level)
            outfile.write('institution=%s,\n' % quote_python(self.institution).encode(ExternalEncoding))
        if self.creation_date is not None:
            showIndent(outfile, level)
            outfile.write('creation_date=%s,\n' % quote_python(self.creation_date).encode(ExternalEncoding))
        if self.modification_date is not None:
            showIndent(outfile, level)
            outfile.write('modification_date=%s,\n' % quote_python(self.modification_date).encode(ExternalEncoding))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.species is not None:
            showIndent(outfile, level)
            outfile.write('species=%s,\n' % quote_python(self.species).encode(ExternalEncoding))
        if self.legal_notice is not None:
            showIndent(outfile, level)
            outfile.write('legal_notice=%s,\n' % quote_python(self.legal_notice).encode(ExternalEncoding))
        if self.reference is not None:
            showIndent(outfile, level)
            outfile.write('reference=%s,\n' % quote_python(self.reference).encode(ExternalEncoding))
        if self.email is not None:
            showIndent(outfile, level)
            outfile.write('email=%s,\n' % quote_python(self.email).encode(ExternalEncoding))
        if self.url is not None:
            showIndent(outfile, level)
            outfile.write('url=%s,\n' % quote_python(self.url).encode(ExternalEncoding))
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.metadata is not None:
            showIndent(outfile, level)
            outfile.write('metadata=model_.Metadata(\n')
            self.metadata.exportLiteral(outfile, level, name_='metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('version')
        if value is not None:
            self.version = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'generator':
            generator_ = child_.text
            self.generator = generator_
        elif nodeName_ == 'author':
            author_ = child_.text
            self.author = author_
        elif nodeName_ == 'institution':
            institution_ = child_.text
            self.institution = institution_
        elif nodeName_ == 'creation-date':
            creation_date_ = child_.text
            self.creation_date = creation_date_
        elif nodeName_ == 'modification-date':
            modification_date_ = child_.text
            self.modification_date = modification_date_
        elif nodeName_ == 'name':
            name_ = child_.text
            self.name = name_
        elif nodeName_ == 'species':
            species_ = child_.text
            self.species = species_
        elif nodeName_ == 'legal-notice':
            legal_notice_ = child_.text
            self.legal_notice = legal_notice_
        elif nodeName_ == 'reference':
            reference_ = child_.text
            self.reference = reference_
        elif nodeName_ == 'email':
            email_ = child_.text
            self.email = email_
        elif nodeName_ == 'url':
            url_ = child_.text
            self.url = url_
        elif nodeName_ == 'description': 
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'metadata': 
            obj_ = Metadata.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
# end class CMetadata


class description(GeneratedsSuper):
    """A description according to the format attribute syntax."""
    subclass = None
    superclass = None
    def __init__(self, format=None, valueOf_=None):
        self.format = _cast(None, format)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if description.subclass:
            return description.subclass(*args_, **kwargs_)
        else:
            return description(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def validate_descriptionFormat(self, value):
        # Validate type descriptionFormat, a restriction on xsd:string.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='description', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='description')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='description'):
        if self.format is not None:
            outfile.write(' format=%s' % (quote_attrib(self.format), ))
    def exportChildren(self, outfile, level, namespace_='', name_='description'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='description'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.format is not None:
            showIndent(outfile, level)
            outfile.write('format = "%s",\n' % (self.format,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('format')
        if value is not None:
            self.format = value
            self.validate_descriptionFormat(self.format)    # validate type descriptionFormat
    def buildChildren(self, child_, nodeName_):
        pass
# end class description


class CNetwork(GeneratedsSuper):
    """The short name of the network The path to the file according to
    location attribute Is the network stored it "GEXF" or "GraphML"
    format, or "Other" format? - dtype="AttributeNetwork" A network
    with arbitrary number of attributes for nodes and edges. -
    dtype="DynamicNetwork" Network with either with lifespan
    attributes for nodes and edges (See GEXF) or timeseries on nodes
    and edges. - dtype="HierarchicalNetwork" Network with
    hierarchical structure. - dtype="Other" Other kind of network."""
    subclass = None
    superclass = None
    def __init__(self, src=None, dtype='AttributeNetwork', name=None, fileformat='GraphML', metadata=None, network_surface=None, network_volume=None, network_track=None, network_timeserie=None, network_data=None, description=None):
        self.src = _cast(None, src)
        self.dtype = _cast(None, dtype)
        self.name = _cast(None, name)
        self.fileformat = _cast(None, fileformat)
        self.metadata = metadata
        if network_surface is None:
            self.network_surface = []
        else:
            self.network_surface = network_surface
        if network_volume is None:
            self.network_volume = []
        else:
            self.network_volume = network_volume
        if network_track is None:
            self.network_track = []
        else:
            self.network_track = network_track
        if network_timeserie is None:
            self.network_timeserie = []
        else:
            self.network_timeserie = network_timeserie
        if network_data is None:
            self.network_data = []
        else:
            self.network_data = network_data
        self.description = description
    def factory(*args_, **kwargs_):
        if CNetwork.subclass:
            return CNetwork.subclass(*args_, **kwargs_)
        else:
            return CNetwork(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    def get_network_surface(self): return self.network_surface
    def set_network_surface(self, network_surface): self.network_surface = network_surface
    def add_network_surface(self, value): self.network_surface.append(value)
    def insert_network_surface(self, index, value): self.network_surface[index] = value
    def get_network_volume(self): return self.network_volume
    def set_network_volume(self, network_volume): self.network_volume = network_volume
    def add_network_volume(self, value): self.network_volume.append(value)
    def insert_network_volume(self, index, value): self.network_volume[index] = value
    def get_network_track(self): return self.network_track
    def set_network_track(self, network_track): self.network_track = network_track
    def add_network_track(self, value): self.network_track.append(value)
    def insert_network_track(self, index, value): self.network_track[index] = value
    def get_network_timeserie(self): return self.network_timeserie
    def set_network_timeserie(self, network_timeserie): self.network_timeserie = network_timeserie
    def add_network_timeserie(self, value): self.network_timeserie.append(value)
    def insert_network_timeserie(self, index, value): self.network_timeserie[index] = value
    def get_network_data(self): return self.network_data
    def set_network_data(self, network_data): self.network_data = network_data
    def add_network_data(self, value): self.network_data.append(value)
    def insert_network_data(self, index, value): self.network_data[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_src(self): return self.src
    def set_src(self, src): self.src = src
    def get_dtype(self): return self.dtype
    def set_dtype(self, dtype): self.dtype = dtype
    def validate_networkEnumDType(self, value):
        # Validate type networkEnumDType, a restriction on xsd:string.
        pass
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_fileformat(self): return self.fileformat
    def set_fileformat(self, fileformat): self.fileformat = fileformat
    def validate_networkFileFormat(self, value):
        # Validate type networkFileFormat, a restriction on xsd:string.
        pass
    def export(self, outfile, level, namespace_='', name_='CNetwork', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='CNetwork')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='CNetwork'):
        if self.src is not None:
            outfile.write(' src=%s' % (self.format_string(quote_attrib(self.src).encode(ExternalEncoding), input_name='src'), ))
        if self.dtype is not None:
            outfile.write(' dtype=%s' % (quote_attrib(self.dtype), ))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.fileformat is not None:
            outfile.write(' fileformat=%s' % (quote_attrib(self.fileformat), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CNetwork'):
        if self.metadata:
            self.metadata.export(outfile, level, namespace_, name_='metadata')
        for network_surface_ in self.network_surface:
            network_surface_.export(outfile, level, namespace_, name_='network-surface')
        for network_volume_ in self.network_volume:
            network_volume_.export(outfile, level, namespace_, name_='network-volume')
        for network_track_ in self.network_track:
            network_track_.export(outfile, level, namespace_, name_='network-track')
        for network_timeserie_ in self.network_timeserie:
            network_timeserie_.export(outfile, level, namespace_, name_='network-timeserie')
        for network_data_ in self.network_data:
            network_data_.export(outfile, level, namespace_, name_='network-data')
        if self.description:
            self.description.export(outfile, level, namespace_, name_='description')
    def hasContent_(self):
        if (
            self.metadata is not None or
            self.network_surface or
            self.network_volume or
            self.network_track or
            self.network_timeserie or
            self.network_data or
            self.description is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CNetwork'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.src is not None:
            showIndent(outfile, level)
            outfile.write('src = "%s",\n' % (self.src,))
        if self.dtype is not None:
            showIndent(outfile, level)
            outfile.write('dtype = "%s",\n' % (self.dtype,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.fileformat is not None:
            showIndent(outfile, level)
            outfile.write('fileformat = "%s",\n' % (self.fileformat,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.metadata is not None:
            showIndent(outfile, level)
            outfile.write('metadata=model_.Metadata(\n')
            self.metadata.exportLiteral(outfile, level, name_='metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('network_surface=[\n')
        level += 1
        for network_surface_ in self.network_surface:
            showIndent(outfile, level)
            outfile.write('model_.NetworkSurface(\n')
            network_surface_.exportLiteral(outfile, level, name_='NetworkSurface')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('network_volume=[\n')
        level += 1
        for network_volume_ in self.network_volume:
            showIndent(outfile, level)
            outfile.write('model_.NetworkVolume(\n')
            network_volume_.exportLiteral(outfile, level, name_='NetworkVolume')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('network_track=[\n')
        level += 1
        for network_track_ in self.network_track:
            showIndent(outfile, level)
            outfile.write('model_.NetworkTrack(\n')
            network_track_.exportLiteral(outfile, level, name_='NetworkTrack')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('network_timeserie=[\n')
        level += 1
        for network_timeserie_ in self.network_timeserie:
            showIndent(outfile, level)
            outfile.write('model_.NetworkTimeserie(\n')
            network_timeserie_.exportLiteral(outfile, level, name_='NetworkTimeserie')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('network_data=[\n')
        level += 1
        for network_data_ in self.network_data:
            showIndent(outfile, level)
            outfile.write('model_.NetworkData(\n')
            network_data_.exportLiteral(outfile, level, name_='NetworkData')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('src')
        if value is not None:
            self.src = value
        value = attrs.get('dtype')
        if value is not None:
            self.dtype = value
            self.validate_networkEnumDType(self.dtype)    # validate type networkEnumDType
        value = attrs.get('name')
        if value is not None:
            self.name = value
        value = attrs.get('fileformat')
        if value is not None:
            self.fileformat = value
            self.validate_networkFileFormat(self.fileformat)    # validate type networkFileFormat
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'metadata': 
            obj_ = Metadata.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
        elif nodeName_ == 'network-surface': 
            obj_ = NetworkSurface.factory()
            obj_.build(child_)
            self.network_surface.append(obj_)
        elif nodeName_ == 'network-volume': 
            obj_ = NetworkVolume.factory()
            obj_.build(child_)
            self.network_volume.append(obj_)
        elif nodeName_ == 'network-track': 
            obj_ = NetworkTrack.factory()
            obj_.build(child_)
            self.network_track.append(obj_)
        elif nodeName_ == 'network-timeserie': 
            obj_ = NetworkTimeserie.factory()
            obj_.build(child_)
            self.network_timeserie.append(obj_)
        elif nodeName_ == 'network-data': 
            obj_ = NetworkData.factory()
            obj_.build(child_)
            self.network_data.append(obj_)
        elif nodeName_ == 'description': 
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
# end class CNetwork


class CSurface(GeneratedsSuper):
    """Descriptive name of the surface. The path to the file according to
    location attribute Set to "gifti" to use the only supported
    Gifti format by cfflib. See
    http://www.nitrc.org/frs/download.php/158/gifti.xsd for schema
    information Use "Other" for other formats with custom IO
    Handling What type of surface does the Gifti file contain: -
    type="label" The Gifti file contains surface labels. This file
    can be referenced in connectome-network with either the name
    attribute or in addition to another surface defined by name and
    using the labelname attribute and matching labelid. If
    referenced in such a way, the networks' nodes attribute
    dn_intensityvalue value may match the label array integers,
    thereby relating a network node to a surface patch (a region of
    interest defined on the surface). See also example datasets. -
    type="surfaceset" The Gifti file contains a set of surfaces
    where the metadata tag AnatomicalStructurePrimary match.
    Individual elements of the set are distinguished by the metadta
    tag AnatomicalStructureSecondary. The Gifti file contains
    information about the coordinate system used. -
    type="surfaceset+label" If the Gifti file contains data as
    described for both surfaceset and label above. - type="other"
    Any other kind of data storable in a Gifti file."""
    subclass = None
    superclass = None
    def __init__(self, src=None, dtype=None, name=None, fileformat=None, description=None, metadata=None):
        self.src = _cast(None, src)
        self.dtype = _cast(None, dtype)
        self.name = _cast(None, name)
        self.fileformat = _cast(None, fileformat)
        self.description = description
        self.metadata = metadata
    def factory(*args_, **kwargs_):
        if CSurface.subclass:
            return CSurface.subclass(*args_, **kwargs_)
        else:
            return CSurface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    def get_src(self): return self.src
    def set_src(self, src): self.src = src
    def get_dtype(self): return self.dtype
    def set_dtype(self, dtype): self.dtype = dtype
    def validate_surfaceEnumDType(self, value):
        # Validate type surfaceEnumDType, a restriction on xsd:string.
        pass
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_fileformat(self): return self.fileformat
    def set_fileformat(self, fileformat): self.fileformat = fileformat
    def validate_surfaceFileFormat(self, value):
        # Validate type surfaceFileFormat, a restriction on xsd:string.
        pass
    def export(self, outfile, level, namespace_='', name_='CSurface', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='CSurface')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='CSurface'):
        if self.src is not None:
            outfile.write(' src=%s' % (self.format_string(quote_attrib(self.src).encode(ExternalEncoding), input_name='src'), ))
        if self.dtype is not None:
            outfile.write(' dtype=%s' % (quote_attrib(self.dtype), ))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.fileformat is not None:
            outfile.write(' fileformat=%s' % (quote_attrib(self.fileformat), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CSurface'):
        if self.description:
            self.description.export(outfile, level, namespace_, name_='description')
        if self.metadata:
            self.metadata.export(outfile, level, namespace_, name_='metadata', )
    def hasContent_(self):
        if (
            self.description is not None or
            self.metadata is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CSurface'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.src is not None:
            showIndent(outfile, level)
            outfile.write('src = "%s",\n' % (self.src,))
        if self.dtype is not None:
            showIndent(outfile, level)
            outfile.write('dtype = "%s",\n' % (self.dtype,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.fileformat is not None:
            showIndent(outfile, level)
            outfile.write('fileformat = "%s",\n' % (self.fileformat,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.metadata is not None:
            showIndent(outfile, level)
            outfile.write('metadata=model_.Metadata(\n')
            self.metadata.exportLiteral(outfile, level, name_='metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('src')
        if value is not None:
            self.src = value
        value = attrs.get('dtype')
        if value is not None:
            self.dtype = value
            self.validate_surfaceEnumDType(self.dtype)    # validate type surfaceEnumDType
        value = attrs.get('name')
        if value is not None:
            self.name = value
        value = attrs.get('fileformat')
        if value is not None:
            self.fileformat = value
            self.validate_surfaceFileFormat(self.fileformat)    # validate type surfaceFileFormat
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'description': 
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'metadata': 
            obj_ = Metadata.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
# end class CSurface


class CVolume(GeneratedsSuper):
    """Name of the volume. The path to the file according to location
    attribute Set to "Nifti1" to use the only supported Nifti
    format. This works also for compressed files with name ending
    .nii.gz The Nifti file contains information about the coordinate
    system used. Set type of volume the Nifti file contains: -
    type="segmentation" The Nifti file contains a single volume
    where the voxel values are integers, representing a segmented
    Region of Interest. If this volume is referenced by a
    connectome-network, its nodes dn_intensityvalue attribute may
    match these integer values. Such a segmentation volume can
    referenced in a connectome-volume by the segmentationname
    attribute in addition to another, e.g. T1-weighted volume which
    is referenced by the name attribute. See also example datasets.
    - type="T1-weighted" The Nifti file contains a T1-weighted
    volume. - type="T2-weighted" The Nifti file contains a
    T2-weighted volume. - type="PD-weighted" The voxel values
    represent a proton-density weighted signal. - type="fMRI" The
    Nifti file contains functional MRI time series data. -
    type="probabilitymap" Voxel values are in the range [0,1]. Can
    stand for tissue probability maps. - type="MD" Diffusion-related
    signal. Stands for mean diffusivity. - type="FA" Diffusion-
    related signal. Stands for fractional anisotropy. - type="LD"
    Diffusion-related signal. Stands for longitudinal diffusivity. -
    type="TD" Diffusion-related signal. Stands for transversal
    diffusivity. - type="FLAIR" Stands for Fluid attenuated
    inversion recovery - type="MRA" Stands for Magnetic resonance
    angiography - type="MRS" Stands for Magnetic resonance
    spectroscopy"""
    subclass = None
    superclass = None
    def __init__(self, src=None, dtype=None, name=None, fileformat='Nifti1', description=None, metadata=None):
        self.src = _cast(None, src)
        self.dtype = _cast(None, dtype)
        self.name = _cast(None, name)
        self.fileformat = _cast(None, fileformat)
        self.description = description
        self.metadata = metadata
    def factory(*args_, **kwargs_):
        if CVolume.subclass:
            return CVolume.subclass(*args_, **kwargs_)
        else:
            return CVolume(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    def get_src(self): return self.src
    def set_src(self, src): self.src = src
    def get_dtype(self): return self.dtype
    def set_dtype(self, dtype): self.dtype = dtype
    def validate_volumeEnumDType(self, value):
        # Validate type volumeEnumDType, a restriction on xsd:string.
        pass
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_fileformat(self): return self.fileformat
    def set_fileformat(self, fileformat): self.fileformat = fileformat
    def validate_volumeFileFormat(self, value):
        # Validate type volumeFileFormat, a restriction on xsd:string.
        pass
    def export(self, outfile, level, namespace_='', name_='CVolume', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='CVolume')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='CVolume'):
        if self.src is not None:
            outfile.write(' src=%s' % (self.format_string(quote_attrib(self.src).encode(ExternalEncoding), input_name='src'), ))
        if self.dtype is not None:
            outfile.write(' dtype=%s' % (quote_attrib(self.dtype), ))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.fileformat is not None:
            outfile.write(' fileformat=%s' % (quote_attrib(self.fileformat), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CVolume'):
        if self.description:
            self.description.export(outfile, level, namespace_, name_='description')
        if self.metadata:
            self.metadata.export(outfile, level, namespace_, name_='metadata', )
    def hasContent_(self):
        if (
            self.description is not None or
            self.metadata is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CVolume'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.src is not None:
            showIndent(outfile, level)
            outfile.write('src = "%s",\n' % (self.src,))
        if self.dtype is not None:
            showIndent(outfile, level)
            outfile.write('dtype = "%s",\n' % (self.dtype,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.fileformat is not None:
            showIndent(outfile, level)
            outfile.write('fileformat = "%s",\n' % (self.fileformat,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.metadata is not None:
            showIndent(outfile, level)
            outfile.write('metadata=model_.Metadata(\n')
            self.metadata.exportLiteral(outfile, level, name_='metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('src')
        if value is not None:
            self.src = value
        value = attrs.get('dtype')
        if value is not None:
            self.dtype = value
            self.validate_volumeEnumDType(self.dtype)    # validate type volumeEnumDType
        value = attrs.get('name')
        if value is not None:
            self.name = value
        value = attrs.get('fileformat')
        if value is not None:
            self.fileformat = value
            self.validate_volumeFileFormat(self.fileformat)    # validate type volumeFileFormat
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'description': 
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'metadata': 
            obj_ = Metadata.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
# end class CVolume


class CTrack(GeneratedsSuper):
    """Name of the track file. The path to the file according to location
    attribute Set to "TrackVis" (default) to use the only supported
    TrackVis file format. The TrackVis file format allows to store
    any number of additional numerical data on the individual
    fibers."""
    subclass = None
    superclass = None
    def __init__(self, src=None, name=None, fileformat='TrackVis', description=None, metadata=None):
        self.src = _cast(None, src)
        self.name = _cast(None, name)
        self.fileformat = _cast(None, fileformat)
        self.description = description
        self.metadata = metadata
    def factory(*args_, **kwargs_):
        if CTrack.subclass:
            return CTrack.subclass(*args_, **kwargs_)
        else:
            return CTrack(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    def get_src(self): return self.src
    def set_src(self, src): self.src = src
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_fileformat(self): return self.fileformat
    def set_fileformat(self, fileformat): self.fileformat = fileformat
    def validate_trackFileFormat(self, value):
        # Validate type trackFileFormat, a restriction on xsd:string.
        pass
    def export(self, outfile, level, namespace_='', name_='CTrack', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='CTrack')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='CTrack'):
        if self.src is not None:
            outfile.write(' src=%s' % (self.format_string(quote_attrib(self.src).encode(ExternalEncoding), input_name='src'), ))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.fileformat is not None:
            outfile.write(' fileformat=%s' % (quote_attrib(self.fileformat), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CTrack'):
        if self.description:
            self.description.export(outfile, level, namespace_, name_='description')
        if self.metadata:
            self.metadata.export(outfile, level, namespace_, name_='metadata', )
    def hasContent_(self):
        if (
            self.description is not None or
            self.metadata is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CTrack'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.src is not None:
            showIndent(outfile, level)
            outfile.write('src = "%s",\n' % (self.src,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.fileformat is not None:
            showIndent(outfile, level)
            outfile.write('fileformat = "%s",\n' % (self.fileformat,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.metadata is not None:
            showIndent(outfile, level)
            outfile.write('metadata=model_.Metadata(\n')
            self.metadata.exportLiteral(outfile, level, name_='metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('src')
        if value is not None:
            self.src = value
        value = attrs.get('name')
        if value is not None:
            self.name = value
        value = attrs.get('fileformat')
        if value is not None:
            self.fileformat = value
            self.validate_trackFileFormat(self.fileformat)    # validate type trackFileFormat
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'description': 
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'metadata': 
            obj_ = Metadata.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
# end class CTrack


class CTimeserie(GeneratedsSuper):
    """Name of the timeseries. The path to the file according to location
    attribute Set to "HDF5" (default) to use the only supported
    Hierarchical Data File format. The HDF5 allows to store any
    number of time series or other large homogeneous data."""
    subclass = None
    superclass = None
    def __init__(self, src=None, name=None, fileformat='HDF5', description=None, metadata=None):
        self.src = _cast(None, src)
        self.name = _cast(None, name)
        self.fileformat = _cast(None, fileformat)
        self.description = description
        self.metadata = metadata
    def factory(*args_, **kwargs_):
        if CTimeserie.subclass:
            return CTimeserie.subclass(*args_, **kwargs_)
        else:
            return CTimeserie(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    def get_src(self): return self.src
    def set_src(self, src): self.src = src
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_fileformat(self): return self.fileformat
    def set_fileformat(self, fileformat): self.fileformat = fileformat
    def validate_timeserieFileFormat(self, value):
        # Validate type timeserieFileFormat, a restriction on xsd:string.
        pass
    def export(self, outfile, level, namespace_='', name_='CTimeserie', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='CTimeserie')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='CTimeserie'):
        if self.src is not None:
            outfile.write(' src=%s' % (self.format_string(quote_attrib(self.src).encode(ExternalEncoding), input_name='src'), ))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.fileformat is not None:
            outfile.write(' fileformat=%s' % (quote_attrib(self.fileformat), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CTimeserie'):
        if self.description:
            self.description.export(outfile, level, namespace_, name_='description')
        if self.metadata:
            self.metadata.export(outfile, level, namespace_, name_='metadata', )
    def hasContent_(self):
        if (
            self.description is not None or
            self.metadata is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CTimeserie'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.src is not None:
            showIndent(outfile, level)
            outfile.write('src = "%s",\n' % (self.src,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.fileformat is not None:
            showIndent(outfile, level)
            outfile.write('fileformat = "%s",\n' % (self.fileformat,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.metadata is not None:
            showIndent(outfile, level)
            outfile.write('metadata=model_.Metadata(\n')
            self.metadata.exportLiteral(outfile, level, name_='metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('src')
        if value is not None:
            self.src = value
        value = attrs.get('name')
        if value is not None:
            self.name = value
        value = attrs.get('fileformat')
        if value is not None:
            self.fileformat = value
            self.validate_timeserieFileFormat(self.fileformat)    # validate type timeserieFileFormat
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'description': 
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'metadata': 
            obj_ = Metadata.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
# end class CTimeserie


class CData(GeneratedsSuper):
    """Name of the data file The path to the file according to location
    attribute Use one of 'NumPy', 'HDF5', 'XML', 'Other'"""
    subclass = None
    superclass = None
    def __init__(self, src=None, name=None, fileformat=None, description=None, metadata=None):
        self.src = _cast(None, src)
        self.name = _cast(None, name)
        self.fileformat = _cast(None, fileformat)
        self.description = description
        self.metadata = metadata
    def factory(*args_, **kwargs_):
        if CData.subclass:
            return CData.subclass(*args_, **kwargs_)
        else:
            return CData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    def get_src(self): return self.src
    def set_src(self, src): self.src = src
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_fileformat(self): return self.fileformat
    def set_fileformat(self, fileformat): self.fileformat = fileformat
    def validate_dataFileFormat(self, value):
        # Validate type dataFileFormat, a restriction on xsd:string.
        pass
    def export(self, outfile, level, namespace_='', name_='CData', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='CData')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='CData'):
        if self.src is not None:
            outfile.write(' src=%s' % (self.format_string(quote_attrib(self.src).encode(ExternalEncoding), input_name='src'), ))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.fileformat is not None:
            outfile.write(' fileformat=%s' % (quote_attrib(self.fileformat), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CData'):
        if self.description:
            self.description.export(outfile, level, namespace_, name_='description')
        if self.metadata:
            self.metadata.export(outfile, level, namespace_, name_='metadata', )
    def hasContent_(self):
        if (
            self.description is not None or
            self.metadata is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CData'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.src is not None:
            showIndent(outfile, level)
            outfile.write('src = "%s",\n' % (self.src,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.fileformat is not None:
            showIndent(outfile, level)
            outfile.write('fileformat = "%s",\n' % (self.fileformat,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.metadata is not None:
            showIndent(outfile, level)
            outfile.write('metadata=model_.Metadata(\n')
            self.metadata.exportLiteral(outfile, level, name_='metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('src')
        if value is not None:
            self.src = value
        value = attrs.get('name')
        if value is not None:
            self.name = value
        value = attrs.get('fileformat')
        if value is not None:
            self.fileformat = value
            self.validate_dataFileFormat(self.fileformat)    # validate type dataFileFormat
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'description': 
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'metadata': 
            obj_ = Metadata.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
# end class CData


class CScript(GeneratedsSuper):
    """Name of the script file The path to the file according to location
    attribute What kind of script. Use one of "Python" (default),
    "Bash", "Matlab", or "Other"."""
    subclass = None
    superclass = None
    def __init__(self, src=None, type_='Python', name=None, description=None, metadata=None):
        self.src = _cast(None, src)
        self.type_ = _cast(None, type_)
        self.name = _cast(None, name)
        self.description = description
        self.metadata = metadata
    def factory(*args_, **kwargs_):
        if CScript.subclass:
            return CScript.subclass(*args_, **kwargs_)
        else:
            return CScript(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    def get_src(self): return self.src
    def set_src(self, src): self.src = src
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def validate_scriptEnumType(self, value):
        # Validate type scriptEnumType, a restriction on xsd:string.
        pass
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='CScript', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='CScript')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='CScript'):
        if self.src is not None:
            outfile.write(' src=%s' % (self.format_string(quote_attrib(self.src).encode(ExternalEncoding), input_name='src'), ))
        if self.type_ is not None:
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CScript'):
        if self.description:
            self.description.export(outfile, level, namespace_, name_='description')
        if self.metadata:
            self.metadata.export(outfile, level, namespace_, name_='metadata', )
    def hasContent_(self):
        if (
            self.description is not None or
            self.metadata is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CScript'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.src is not None:
            showIndent(outfile, level)
            outfile.write('src = "%s",\n' % (self.src,))
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.metadata is not None:
            showIndent(outfile, level)
            outfile.write('metadata=model_.Metadata(\n')
            self.metadata.exportLiteral(outfile, level, name_='metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('src')
        if value is not None:
            self.src = value
        value = attrs.get('type')
        if value is not None:
            self.type_ = value
            self.validate_scriptEnumType(self.type_)    # validate type scriptEnumType
        value = attrs.get('name')
        if value is not None:
            self.name = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'description': 
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'metadata': 
            obj_ = Metadata.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
# end class CScript


class CImagestack(GeneratedsSuper):
    """Name of the image stack The path to the enumerated files according
    to location attribute The file name pattern that may contain
    simple shell-style wildcards a la fnmatch. Use one of 'PNG',
    'JPG', 'TIFF', 'Other'"""
    subclass = None
    superclass = None
    def __init__(self, src=None, fileformat=None, name=None, pattern=None, description=None, metadata=None):
        self.src = _cast(None, src)
        self.fileformat = _cast(None, fileformat)
        self.name = _cast(None, name)
        self.pattern = _cast(None, pattern)
        self.description = description
        self.metadata = metadata
    def factory(*args_, **kwargs_):
        if CImagestack.subclass:
            return CImagestack.subclass(*args_, **kwargs_)
        else:
            return CImagestack(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    def get_src(self): return self.src
    def set_src(self, src): self.src = src
    def get_fileformat(self): return self.fileformat
    def set_fileformat(self, fileformat): self.fileformat = fileformat
    def validate_imagestackFileFormat(self, value):
        # Validate type imagestackFileFormat, a restriction on xsd:string.
        pass
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_pattern(self): return self.pattern
    def set_pattern(self, pattern): self.pattern = pattern
    def export(self, outfile, level, namespace_='', name_='CImagestack', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='CImagestack')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='CImagestack'):
        if self.src is not None:
            outfile.write(' src=%s' % (self.format_string(quote_attrib(self.src).encode(ExternalEncoding), input_name='src'), ))
        if self.fileformat is not None:
            outfile.write(' fileformat=%s' % (quote_attrib(self.fileformat), ))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.pattern is not None:
            outfile.write(' pattern=%s' % (self.format_string(quote_attrib(self.pattern).encode(ExternalEncoding), input_name='pattern'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CImagestack'):
        if self.description:
            self.description.export(outfile, level, namespace_, name_='description')
        if self.metadata:
            self.metadata.export(outfile, level, namespace_, name_='metadata', )
    def hasContent_(self):
        if (
            self.description is not None or
            self.metadata is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CImagestack'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.src is not None:
            showIndent(outfile, level)
            outfile.write('src = "%s",\n' % (self.src,))
        if self.fileformat is not None:
            showIndent(outfile, level)
            outfile.write('fileformat = "%s",\n' % (self.fileformat,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.pattern is not None:
            showIndent(outfile, level)
            outfile.write('pattern = "%s",\n' % (self.pattern,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.metadata is not None:
            showIndent(outfile, level)
            outfile.write('metadata=model_.Metadata(\n')
            self.metadata.exportLiteral(outfile, level, name_='metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('src')
        if value is not None:
            self.src = value
        value = attrs.get('fileformat')
        if value is not None:
            self.fileformat = value
            self.validate_imagestackFileFormat(self.fileformat)    # validate type imagestackFileFormat
        value = attrs.get('name')
        if value is not None:
            self.name = value
        value = attrs.get('pattern')
        if value is not None:
            self.pattern = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'description': 
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'metadata': 
            obj_ = Metadata.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
# end class CImagestack


class Metadata(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, data=None):
        self.data = data
    def factory(*args_, **kwargs_):
        if Metadata.subclass:
            return Metadata.subclass(*args_, **kwargs_)
        else:
            return Metadata(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_data(self): return self.data
    def set_data(self, data): self.data = data
    def export(self, outfile, level, namespace_='', name_='Metadata', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='Metadata')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='Metadata'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Metadata'):
        if self.data:
            self.data.export(outfile, level, namespace_, name_='data')
    def hasContent_(self):
        if (
            self.data is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Metadata'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.data is not None:
            showIndent(outfile, level)
            outfile.write('data=model_.data(\n')
            self.data.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'data': 
            obj_ = data.factory()
            obj_.build(child_)
            self.set_data(obj_)
# end class Metadata


class data(GeneratedsSuper):
    """A data element contains a key attribute and the value as tag The key
    to be used later in the dictionary"""
    subclass = None
    superclass = None
    def __init__(self, key=None, valueOf_=None):
        self.key = _cast(None, key)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if data.subclass:
            return data.subclass(*args_, **kwargs_)
        else:
            return data(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='data', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='data')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='data'):
        if self.key is not None:
            outfile.write(' key=%s' % (self.format_string(quote_attrib(self.key).encode(ExternalEncoding), input_name='key'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='data'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='data'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('key = "%s",\n' % (self.key,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('key')
        if value is not None:
            self.key = value
    def buildChildren(self, child_, nodeName_):
        pass
# end class data


class NetworkSurface(GeneratedsSuper):
    """The name of the surface as reference to an existing connectome-
    surface"""
    subclass = None
    superclass = None
    def __init__(self, name=None, metadata=None):
        self.name = _cast(None, name)
        self.metadata = metadata
    def factory(*args_, **kwargs_):
        if NetworkSurface.subclass:
            return NetworkSurface.subclass(*args_, **kwargs_)
        else:
            return NetworkSurface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='NetworkSurface', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='NetworkSurface')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='NetworkSurface'):
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkSurface'):
        if self.metadata:
            self.metadata.export(outfile, level, namespace_, name_='metadata')
    def hasContent_(self):
        if (
            self.metadata is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NetworkSurface'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.metadata is not None:
            showIndent(outfile, level)
            outfile.write('metadata=model_.Metadata(\n')
            self.metadata.exportLiteral(outfile, level, name_='metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('name')
        if value is not None:
            self.name = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'metadata': 
            obj_ = Metadata.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
# end class NetworkSurface


class NetworkVolume(GeneratedsSuper):
    """The name of the volume as reference to an existing connectome-
    volume. The connectome-volume can be of any dtype."""
    subclass = None
    superclass = None
    def __init__(self, name=None, metadata=None):
        self.name = _cast(None, name)
        self.metadata = metadata
    def factory(*args_, **kwargs_):
        if NetworkVolume.subclass:
            return NetworkVolume.subclass(*args_, **kwargs_)
        else:
            return NetworkVolume(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='NetworkVolume', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='NetworkVolume')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='NetworkVolume'):
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkVolume'):
        if self.metadata:
            self.metadata.export(outfile, level, namespace_, name_='metadata')
    def hasContent_(self):
        if (
            self.metadata is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NetworkVolume'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.metadata is not None:
            showIndent(outfile, level)
            outfile.write('metadata=model_.Metadata(\n')
            self.metadata.exportLiteral(outfile, level, name_='metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('name')
        if value is not None:
            self.name = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'metadata': 
            obj_ = Metadata.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
# end class NetworkVolume


class NetworkTrack(GeneratedsSuper):
    """The name of the track as reference to an existing connectome-track"""
    subclass = None
    superclass = None
    def __init__(self, name=None, metadata=None):
        self.name = _cast(None, name)
        self.metadata = metadata
    def factory(*args_, **kwargs_):
        if NetworkTrack.subclass:
            return NetworkTrack.subclass(*args_, **kwargs_)
        else:
            return NetworkTrack(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='NetworkTrack', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='NetworkTrack')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='NetworkTrack'):
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkTrack'):
        if self.metadata:
            self.metadata.export(outfile, level, namespace_, name_='metadata')
    def hasContent_(self):
        if (
            self.metadata is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NetworkTrack'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.metadata is not None:
            showIndent(outfile, level)
            outfile.write('metadata=model_.Metadata(\n')
            self.metadata.exportLiteral(outfile, level, name_='metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('name')
        if value is not None:
            self.name = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'metadata': 
            obj_ = Metadata.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
# end class NetworkTrack


class NetworkTimeserie(GeneratedsSuper):
    """The name of the timeserie as reference to an existing connectome-
    timeserie"""
    subclass = None
    superclass = None
    def __init__(self, name=None, metadata=None):
        self.name = _cast(None, name)
        self.metadata = metadata
    def factory(*args_, **kwargs_):
        if NetworkTimeserie.subclass:
            return NetworkTimeserie.subclass(*args_, **kwargs_)
        else:
            return NetworkTimeserie(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='NetworkTimeserie', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='NetworkTimeserie')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='NetworkTimeserie'):
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkTimeserie'):
        if self.metadata:
            self.metadata.export(outfile, level, namespace_, name_='metadata')
    def hasContent_(self):
        if (
            self.metadata is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NetworkTimeserie'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.metadata is not None:
            showIndent(outfile, level)
            outfile.write('metadata=model_.Metadata(\n')
            self.metadata.exportLiteral(outfile, level, name_='metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('name')
        if value is not None:
            self.name = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'metadata': 
            obj_ = Metadata.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
# end class NetworkTimeserie


class NetworkData(GeneratedsSuper):
    """The name of the data object as reference to an existing connectome-
    data"""
    subclass = None
    superclass = None
    def __init__(self, name=None, metadata=None):
        self.name = _cast(None, name)
        self.metadata = metadata
    def factory(*args_, **kwargs_):
        if NetworkData.subclass:
            return NetworkData.subclass(*args_, **kwargs_)
        else:
            return NetworkData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='NetworkData', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='NetworkData')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='NetworkData'):
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkData'):
        if self.metadata:
            self.metadata.export(outfile, level, namespace_, name_='metadata')
    def hasContent_(self):
        if (
            self.metadata is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NetworkData'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.metadata is not None:
            showIndent(outfile, level)
            outfile.write('metadata=model_.Metadata(\n')
            self.metadata.exportLiteral(outfile, level, name_='metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('name')
        if value is not None:
            self.name = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'metadata': 
            obj_ = Metadata.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
# end class NetworkData


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag, 
        namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="connectome",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from cff import *\n\n')
    sys.stdout.write('import cff as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

