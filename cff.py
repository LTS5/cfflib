#!/usr/bin/env python

#
# Generated Wed May 19 11:14:00 2010 by generateDS.py version 1.20f.
#

import sys
import getopt
from string import lower as str_lower
from xml.dom import minidom
from xml.dom import Node

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def format_string(self, input_data, input_name=''):
            return input_data
        def format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def format_boolean(self, input_data, input_name=''):
            return '%s' % input_data


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class connectome(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, connectome_meta=None, connectome_network=None, connectome_surface=None, connectome_volume=None, connectome_track=None, connectome_timeserie=None):
        self.connectome_meta = connectome_meta
        if connectome_network is None:
            self.connectome_network = []
        else:
            self.connectome_network = connectome_network
        if connectome_surface is None:
            self.connectome_surface = []
        else:
            self.connectome_surface = connectome_surface
        if connectome_volume is None:
            self.connectome_volume = []
        else:
            self.connectome_volume = connectome_volume
        if connectome_track is None:
            self.connectome_track = []
        else:
            self.connectome_track = connectome_track
        if connectome_timeserie is None:
            self.connectome_timeserie = []
        else:
            self.connectome_timeserie = connectome_timeserie
    def factory(*args_, **kwargs_):
        if connectome.subclass:
            return connectome.subclass(*args_, **kwargs_)
        else:
            return connectome(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_connectome_meta(self): return self.connectome_meta
    def set_connectome_meta(self, connectome_meta): self.connectome_meta = connectome_meta
    connectome_metaProp = property(get_connectome_meta, set_connectome_meta)
    def get_connectome_network(self): return self.connectome_network
    def set_connectome_network(self, connectome_network): self.connectome_network = connectome_network
    def add_connectome_network(self, value): self.connectome_network.append(value)
    def insert_connectome_network(self, index, value): self.connectome_network[index] = value
    connectome_networkProp = property(get_connectome_network, set_connectome_network)
    def get_connectome_surface(self): return self.connectome_surface
    def set_connectome_surface(self, connectome_surface): self.connectome_surface = connectome_surface
    def add_connectome_surface(self, value): self.connectome_surface.append(value)
    def insert_connectome_surface(self, index, value): self.connectome_surface[index] = value
    connectome_surfaceProp = property(get_connectome_surface, set_connectome_surface)
    def get_connectome_volume(self): return self.connectome_volume
    def set_connectome_volume(self, connectome_volume): self.connectome_volume = connectome_volume
    def add_connectome_volume(self, value): self.connectome_volume.append(value)
    def insert_connectome_volume(self, index, value): self.connectome_volume[index] = value
    connectome_volumeProp = property(get_connectome_volume, set_connectome_volume)
    def get_connectome_track(self): return self.connectome_track
    def set_connectome_track(self, connectome_track): self.connectome_track = connectome_track
    def add_connectome_track(self, value): self.connectome_track.append(value)
    def insert_connectome_track(self, index, value): self.connectome_track[index] = value
    connectome_trackProp = property(get_connectome_track, set_connectome_track)
    def get_connectome_timeserie(self): return self.connectome_timeserie
    def set_connectome_timeserie(self, connectome_timeserie): self.connectome_timeserie = connectome_timeserie
    def add_connectome_timeserie(self, value): self.connectome_timeserie.append(value)
    def insert_connectome_timeserie(self, index, value): self.connectome_timeserie[index] = value
    connectome_timeserieProp = property(get_connectome_timeserie, set_connectome_timeserie)
    def export(self, outfile, level, namespace_='', name_='connectome', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='connectome')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='connectome'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='connectome'):
        if self.connectome_meta:
            self.connectome_meta.export(outfile, level, namespace_, name_='connectome-meta', )
        for connectome_network_ in self.connectome_network:
            connectome_network_.export(outfile, level, namespace_, name_='connectome-network')
        for connectome_surface_ in self.connectome_surface:
            connectome_surface_.export(outfile, level, namespace_, name_='connectome-surface')
        for connectome_volume_ in self.connectome_volume:
            connectome_volume_.export(outfile, level, namespace_, name_='connectome-volume')
        for connectome_track_ in self.connectome_track:
            connectome_track_.export(outfile, level, namespace_, name_='connectome-track')
        for connectome_timeserie_ in self.connectome_timeserie:
            connectome_timeserie_.export(outfile, level, namespace_, name_='connectome-timeserie')
    def hasContent_(self):
        if (
            self.connectome_meta is not None or
            self.connectome_network or
            self.connectome_surface or
            self.connectome_volume or
            self.connectome_track or
            self.connectome_timeserie
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='connectome'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.connectome_meta is not None:
            showIndent(outfile, level)
            outfile.write('connectome_meta=model_.AbstractCMetadata(\n')
            self.connectome_meta.exportLiteral(outfile, level, name_='connectome_meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('connectome_network=[\n')
        level += 1
        for connectome_network_ in self.connectome_network:
            showIndent(outfile, level)
            outfile.write('model_.AbstractCNetwork(\n')
            connectome_network_.exportLiteral(outfile, level, name_='AbstractCNetwork')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('connectome_surface=[\n')
        level += 1
        for connectome_surface_ in self.connectome_surface:
            showIndent(outfile, level)
            outfile.write('model_.AbstractCSurface(\n')
            connectome_surface_.exportLiteral(outfile, level, name_='AbstractCSurface')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('connectome_volume=[\n')
        level += 1
        for connectome_volume_ in self.connectome_volume:
            showIndent(outfile, level)
            outfile.write('model_.AbstractCVolume(\n')
            connectome_volume_.exportLiteral(outfile, level, name_='AbstractCVolume')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('connectome_track=[\n')
        level += 1
        for connectome_track_ in self.connectome_track:
            showIndent(outfile, level)
            outfile.write('model_.AbstractCTrack(\n')
            connectome_track_.exportLiteral(outfile, level, name_='AbstractCTrack')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('connectome_timeserie=[\n')
        level += 1
        for connectome_timeserie_ in self.connectome_timeserie:
            showIndent(outfile, level)
            outfile.write('model_.AbstractCTimeserie(\n')
            connectome_timeserie_.exportLiteral(outfile, level, name_='AbstractCTimeserie')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'connectome-meta':
            obj_ = AbstractCMetadata.factory()
            obj_.build(child_)
            self.set_connectome_meta(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'connectome-network':
            obj_ = AbstractCNetwork.factory()
            obj_.build(child_)
            self.connectome_network.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'connectome-surface':
            obj_ = AbstractCSurface.factory()
            obj_.build(child_)
            self.connectome_surface.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'connectome-volume':
            obj_ = AbstractCVolume.factory()
            obj_.build(child_)
            self.connectome_volume.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'connectome-track':
            obj_ = AbstractCTrack.factory()
            obj_.build(child_)
            self.connectome_track.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'connectome-timeserie':
            obj_ = AbstractCTimeserie.factory()
            obj_.build(child_)
            self.connectome_timeserie.append(obj_)
# end class connectome


class AbstractCMetadata(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, generator=None, initial_creator=None, institution=None, creation_date=None, modification_date=None, name=None, species=None, legal_notice=None, reference=None, url=None, description=None, metadata=None):
        self.version = _cast(None, version)
        self.generator = generator
        self.initial_creator = initial_creator
        self.institution = institution
        self.creation_date = creation_date
        self.modification_date = modification_date
        self.name = name
        self.species = species
        self.legal_notice = legal_notice
        self.reference = reference
        self.url = url
        self.description = description
        self.metadata = metadata
    def factory(*args_, **kwargs_):
        if AbstractCMetadata.subclass:
            return AbstractCMetadata.subclass(*args_, **kwargs_)
        else:
            return AbstractCMetadata(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_generator(self): return self.generator
    def set_generator(self, generator): self.generator = generator
    generatorProp = property(get_generator, set_generator)
    def get_initial_creator(self): return self.initial_creator
    def set_initial_creator(self, initial_creator): self.initial_creator = initial_creator
    initial_creatorProp = property(get_initial_creator, set_initial_creator)
    def get_institution(self): return self.institution
    def set_institution(self, institution): self.institution = institution
    institutionProp = property(get_institution, set_institution)
    def get_creation_date(self): return self.creation_date
    def set_creation_date(self, creation_date): self.creation_date = creation_date
    creation_dateProp = property(get_creation_date, set_creation_date)
    def get_modification_date(self): return self.modification_date
    def set_modification_date(self, modification_date): self.modification_date = modification_date
    modification_dateProp = property(get_modification_date, set_modification_date)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    nameProp = property(get_name, set_name)
    def get_species(self): return self.species
    def set_species(self, species): self.species = species
    speciesProp = property(get_species, set_species)
    def get_legal_notice(self): return self.legal_notice
    def set_legal_notice(self, legal_notice): self.legal_notice = legal_notice
    legal_noticeProp = property(get_legal_notice, set_legal_notice)
    def get_reference(self): return self.reference
    def set_reference(self, reference): self.reference = reference
    referenceProp = property(get_reference, set_reference)
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    urlProp = property(get_url, set_url)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    descriptionProp = property(get_description, set_description)
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    metadataProp = property(get_metadata, set_metadata)
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    versionProp = property(get_version, set_version)
    def export(self, outfile, level, namespace_='', name_='AbstractCMetadata', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractCMetadata')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='AbstractCMetadata'):
        outfile.write(' version=%s' % (self.format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractCMetadata'):
        if self.generator is not None:
            showIndent(outfile, level)
            outfile.write('<%sgenerator>%s</%sgenerator>\n' % (namespace_, self.format_string(quote_xml(self.generator).encode(ExternalEncoding), input_name='generator'), namespace_))
        if self.initial_creator is not None:
            showIndent(outfile, level)
            outfile.write('<%sinitial-creator>%s</%sinitial-creator>\n' % (namespace_, self.format_string(quote_xml(self.initial_creator).encode(ExternalEncoding), input_name='initial-creator'), namespace_))
        if self.institution is not None:
            showIndent(outfile, level)
            outfile.write('<%sinstitution>%s</%sinstitution>\n' % (namespace_, self.format_string(quote_xml(self.institution).encode(ExternalEncoding), input_name='institution'), namespace_))
        if self.creation_date is not None:
            showIndent(outfile, level)
            outfile.write('<%screation-date>%s</%screation-date>\n' % (namespace_, self.format_string(quote_xml(self.creation_date).encode(ExternalEncoding), input_name='creation-date'), namespace_))
        if self.modification_date is not None:
            showIndent(outfile, level)
            outfile.write('<%smodification-date>%s</%smodification-date>\n' % (namespace_, self.format_string(quote_xml(self.modification_date).encode(ExternalEncoding), input_name='modification-date'), namespace_))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('<%sname>%s</%sname>\n' % (namespace_, self.format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_))
        if self.species is not None:
            showIndent(outfile, level)
            outfile.write('<%sspecies>%s</%sspecies>\n' % (namespace_, self.format_string(quote_xml(self.species).encode(ExternalEncoding), input_name='species'), namespace_))
        if self.legal_notice is not None:
            showIndent(outfile, level)
            outfile.write('<%slegal-notice>%s</%slegal-notice>\n' % (namespace_, self.format_string(quote_xml(self.legal_notice).encode(ExternalEncoding), input_name='legal-notice'), namespace_))
        if self.reference is not None:
            showIndent(outfile, level)
            outfile.write('<%sreference>%s</%sreference>\n' % (namespace_, self.format_string(quote_xml(self.reference).encode(ExternalEncoding), input_name='reference'), namespace_))
        if self.url is not None:
            showIndent(outfile, level)
            outfile.write('<%surl>%s</%surl>\n' % (namespace_, self.format_string(quote_xml(self.url).encode(ExternalEncoding), input_name='url'), namespace_))
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        if self.metadata:
            self.metadata.export(outfile, level, namespace_, name_='metadata')
    def hasContent_(self):
        if (
            self.generator is not None or
            self.initial_creator is not None or
            self.institution is not None or
            self.creation_date is not None or
            self.modification_date is not None or
            self.name is not None or
            self.species is not None or
            self.legal_notice is not None or
            self.reference is not None or
            self.url is not None or
            self.description is not None or
            self.metadata is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractCMetadata'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version = "%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.generator is not None:
            showIndent(outfile, level)
            outfile.write('generator=%s,\n' % quote_python(self.generator).encode(ExternalEncoding))
        if self.initial_creator is not None:
            showIndent(outfile, level)
            outfile.write('initial_creator=%s,\n' % quote_python(self.initial_creator).encode(ExternalEncoding))
        if self.institution is not None:
            showIndent(outfile, level)
            outfile.write('institution=%s,\n' % quote_python(self.institution).encode(ExternalEncoding))
        if self.creation_date is not None:
            showIndent(outfile, level)
            outfile.write('creation_date=%s,\n' % quote_python(self.creation_date).encode(ExternalEncoding))
        if self.modification_date is not None:
            showIndent(outfile, level)
            outfile.write('modification_date=%s,\n' % quote_python(self.modification_date).encode(ExternalEncoding))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.species is not None:
            showIndent(outfile, level)
            outfile.write('species=%s,\n' % quote_python(self.species).encode(ExternalEncoding))
        if self.legal_notice is not None:
            showIndent(outfile, level)
            outfile.write('legal_notice=%s,\n' % quote_python(self.legal_notice).encode(ExternalEncoding))
        if self.reference is not None:
            showIndent(outfile, level)
            outfile.write('reference=%s,\n' % quote_python(self.reference).encode(ExternalEncoding))
        if self.url is not None:
            showIndent(outfile, level)
            outfile.write('url=%s,\n' % quote_python(self.url).encode(ExternalEncoding))
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.metadata is not None:
            showIndent(outfile, level)
            outfile.write('metadata=model_.AbstractKVPair(\n')
            self.metadata.exportLiteral(outfile, level, name_='metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('version'):
            self.version = attrs.get('version').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'generator':
            generator_ = ''
            for text__content_ in child_.childNodes:
                generator_ += text__content_.nodeValue
            self.generator = generator_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'initial-creator':
            initial_creator_ = ''
            for text__content_ in child_.childNodes:
                initial_creator_ += text__content_.nodeValue
            self.initial_creator = initial_creator_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'institution':
            institution_ = ''
            for text__content_ in child_.childNodes:
                institution_ += text__content_.nodeValue
            self.institution = institution_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'creation-date':
            creation_date_ = ''
            for text__content_ in child_.childNodes:
                creation_date_ += text__content_.nodeValue
            self.creation_date = creation_date_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'modification-date':
            modification_date_ = ''
            for text__content_ in child_.childNodes:
                modification_date_ += text__content_.nodeValue
            self.modification_date = modification_date_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'name':
            name_ = ''
            for text__content_ in child_.childNodes:
                name_ += text__content_.nodeValue
            self.name = name_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'species':
            species_ = ''
            for text__content_ in child_.childNodes:
                species_ += text__content_.nodeValue
            self.species = species_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'legal-notice':
            legal_notice_ = ''
            for text__content_ in child_.childNodes:
                legal_notice_ += text__content_.nodeValue
            self.legal_notice = legal_notice_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'reference':
            reference_ = ''
            for text__content_ in child_.childNodes:
                reference_ += text__content_.nodeValue
            self.reference = reference_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'url':
            url_ = ''
            for text__content_ in child_.childNodes:
                url_ += text__content_.nodeValue
            self.url = url_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'description':
            description_ = ''
            for text__content_ in child_.childNodes:
                description_ += text__content_.nodeValue
            self.description = description_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'metadata':
            obj_ = AbstractKVPair.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
# end class AbstractCMetadata


class AbstractCNetwork(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, src=None, name=None, dtype=None, network_metadata=None, network_surface=None, network_volume=None, network_track=None, network_timeserie=None, description=None):
        self.src = _cast(None, src)
        self.name = _cast(None, name)
        self.dtype = _cast(None, dtype)
        self.network_metadata = network_metadata
        if network_surface is None:
            self.network_surface = []
        else:
            self.network_surface = network_surface
        if network_volume is None:
            self.network_volume = []
        else:
            self.network_volume = network_volume
        if network_track is None:
            self.network_track = []
        else:
            self.network_track = network_track
        if network_timeserie is None:
            self.network_timeserie = []
        else:
            self.network_timeserie = network_timeserie
        self.description = description
    def factory(*args_, **kwargs_):
        if AbstractCNetwork.subclass:
            return AbstractCNetwork.subclass(*args_, **kwargs_)
        else:
            return AbstractCNetwork(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_network_metadata(self): return self.network_metadata
    def set_network_metadata(self, network_metadata): self.network_metadata = network_metadata
    network_metadataProp = property(get_network_metadata, set_network_metadata)
    def get_network_surface(self): return self.network_surface
    def set_network_surface(self, network_surface): self.network_surface = network_surface
    def add_network_surface(self, value): self.network_surface.append(value)
    def insert_network_surface(self, index, value): self.network_surface[index] = value
    network_surfaceProp = property(get_network_surface, set_network_surface)
    def get_network_volume(self): return self.network_volume
    def set_network_volume(self, network_volume): self.network_volume = network_volume
    def add_network_volume(self, value): self.network_volume.append(value)
    def insert_network_volume(self, index, value): self.network_volume[index] = value
    network_volumeProp = property(get_network_volume, set_network_volume)
    def get_network_track(self): return self.network_track
    def set_network_track(self, network_track): self.network_track = network_track
    def add_network_track(self, value): self.network_track.append(value)
    def insert_network_track(self, index, value): self.network_track[index] = value
    network_trackProp = property(get_network_track, set_network_track)
    def get_network_timeserie(self): return self.network_timeserie
    def set_network_timeserie(self, network_timeserie): self.network_timeserie = network_timeserie
    def add_network_timeserie(self, value): self.network_timeserie.append(value)
    def insert_network_timeserie(self, index, value): self.network_timeserie[index] = value
    network_timeserieProp = property(get_network_timeserie, set_network_timeserie)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    descriptionProp = property(get_description, set_description)
    def get_src(self): return self.src
    def set_src(self, src): self.src = src
    srcProp = property(get_src, set_src)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    nameProp = property(get_name, set_name)
    def get_dtype(self): return self.dtype
    def set_dtype(self, dtype): self.dtype = dtype
    dtypeProp = property(get_dtype, set_dtype)
    def export(self, outfile, level, namespace_='', name_='AbstractCNetwork', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractCNetwork')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='AbstractCNetwork'):
        if self.src is not None:
            outfile.write(' src=%s' % (self.format_string(quote_attrib(self.src).encode(ExternalEncoding), input_name='src'), ))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.dtype is not None:
            outfile.write(' dtype=%s' % (self.format_string(quote_attrib(self.dtype).encode(ExternalEncoding), input_name='dtype'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractCNetwork'):
        if self.network_metadata:
            self.network_metadata.export(outfile, level, namespace_, name_='network-metadata')
        for network_surface_ in self.network_surface:
            network_surface_.export(outfile, level, namespace_, name_='network-surface')
        for network_volume_ in self.network_volume:
            network_volume_.export(outfile, level, namespace_, name_='network-volume')
        for network_track_ in self.network_track:
            network_track_.export(outfile, level, namespace_, name_='network-track')
        for network_timeserie_ in self.network_timeserie:
            network_timeserie_.export(outfile, level, namespace_, name_='network-timeserie')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
    def hasContent_(self):
        if (
            self.network_metadata is not None or
            self.network_surface or
            self.network_volume or
            self.network_track or
            self.network_timeserie or
            self.description is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractCNetwork'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.src is not None:
            showIndent(outfile, level)
            outfile.write('src = "%s",\n' % (self.src,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.dtype is not None:
            showIndent(outfile, level)
            outfile.write('dtype = "%s",\n' % (self.dtype,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.network_metadata is not None:
            showIndent(outfile, level)
            outfile.write('network_metadata=model_.AbstractKVPair(\n')
            self.network_metadata.exportLiteral(outfile, level, name_='network_metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('network_surface=[\n')
        level += 1
        for network_surface_ in self.network_surface:
            showIndent(outfile, level)
            outfile.write('model_.AbstractCNetworkSurface(\n')
            network_surface_.exportLiteral(outfile, level, name_='AbstractCNetworkSurface')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('network_volume=[\n')
        level += 1
        for network_volume_ in self.network_volume:
            showIndent(outfile, level)
            outfile.write('model_.AbstractCNetworkVolume(\n')
            network_volume_.exportLiteral(outfile, level, name_='AbstractCNetworkVolume')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('network_track=[\n')
        level += 1
        for network_track_ in self.network_track:
            showIndent(outfile, level)
            outfile.write('model_.AbstractCNetworkTrack(\n')
            network_track_.exportLiteral(outfile, level, name_='AbstractCNetworkTrack')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('network_timeserie=[\n')
        level += 1
        for network_timeserie_ in self.network_timeserie:
            showIndent(outfile, level)
            outfile.write('model_.AbstractCNetworkTimeserie(\n')
            network_timeserie_.exportLiteral(outfile, level, name_='AbstractCNetworkTimeserie')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('src'):
            self.src = attrs.get('src').value
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('dtype'):
            self.dtype = attrs.get('dtype').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'network-metadata':
            obj_ = AbstractKVPair.factory()
            obj_.build(child_)
            self.set_network_metadata(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'network-surface':
            obj_ = AbstractCNetworkSurface.factory()
            obj_.build(child_)
            self.network_surface.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'network-volume':
            obj_ = AbstractCNetworkVolume.factory()
            obj_.build(child_)
            self.network_volume.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'network-track':
            obj_ = AbstractCNetworkTrack.factory()
            obj_.build(child_)
            self.network_track.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'network-timeserie':
            obj_ = AbstractCNetworkTimeserie.factory()
            obj_.build(child_)
            self.network_timeserie.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'description':
            description_ = ''
            for text__content_ in child_.childNodes:
                description_ += text__content_.nodeValue
            self.description = description_
# end class AbstractCNetwork


class AbstractCSurface(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, src=None, dtype=None, name=None, fileformat=None, description=None):
        self.src = _cast(None, src)
        self.dtype = _cast(None, dtype)
        self.name = _cast(None, name)
        self.fileformat = _cast(None, fileformat)
        self.description = description
    def factory(*args_, **kwargs_):
        if AbstractCSurface.subclass:
            return AbstractCSurface.subclass(*args_, **kwargs_)
        else:
            return AbstractCSurface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    descriptionProp = property(get_description, set_description)
    def get_src(self): return self.src
    def set_src(self, src): self.src = src
    srcProp = property(get_src, set_src)
    def get_dtype(self): return self.dtype
    def set_dtype(self, dtype): self.dtype = dtype
    dtypeProp = property(get_dtype, set_dtype)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    nameProp = property(get_name, set_name)
    def get_fileformat(self): return self.fileformat
    def set_fileformat(self, fileformat): self.fileformat = fileformat
    fileformatProp = property(get_fileformat, set_fileformat)
    def export(self, outfile, level, namespace_='', name_='AbstractCSurface', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractCSurface')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='AbstractCSurface'):
        if self.src is not None:
            outfile.write(' src=%s' % (self.format_string(quote_attrib(self.src).encode(ExternalEncoding), input_name='src'), ))
        if self.dtype is not None:
            outfile.write(' dtype=%s' % (self.format_string(quote_attrib(self.dtype).encode(ExternalEncoding), input_name='dtype'), ))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.fileformat is not None:
            outfile.write(' fileformat=%s' % (self.format_string(quote_attrib(self.fileformat).encode(ExternalEncoding), input_name='fileformat'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractCSurface'):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
    def hasContent_(self):
        if (
            self.description is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractCSurface'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.src is not None:
            showIndent(outfile, level)
            outfile.write('src = "%s",\n' % (self.src,))
        if self.dtype is not None:
            showIndent(outfile, level)
            outfile.write('dtype = "%s",\n' % (self.dtype,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.fileformat is not None:
            showIndent(outfile, level)
            outfile.write('fileformat = "%s",\n' % (self.fileformat,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('src'):
            self.src = attrs.get('src').value
        if attrs.get('dtype'):
            self.dtype = attrs.get('dtype').value
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('fileformat'):
            self.fileformat = attrs.get('fileformat').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'description':
            description_ = ''
            for text__content_ in child_.childNodes:
                description_ += text__content_.nodeValue
            self.description = description_
# end class AbstractCSurface


class AbstractCVolume(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, src=None, dtype=None, name=None, fileformat=None, description=None):
        self.src = _cast(None, src)
        self.dtype = _cast(None, dtype)
        self.name = _cast(None, name)
        self.fileformat = _cast(None, fileformat)
        self.description = description
    def factory(*args_, **kwargs_):
        if AbstractCVolume.subclass:
            return AbstractCVolume.subclass(*args_, **kwargs_)
        else:
            return AbstractCVolume(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    descriptionProp = property(get_description, set_description)
    def get_src(self): return self.src
    def set_src(self, src): self.src = src
    srcProp = property(get_src, set_src)
    def get_dtype(self): return self.dtype
    def set_dtype(self, dtype): self.dtype = dtype
    dtypeProp = property(get_dtype, set_dtype)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    nameProp = property(get_name, set_name)
    def get_fileformat(self): return self.fileformat
    def set_fileformat(self, fileformat): self.fileformat = fileformat
    fileformatProp = property(get_fileformat, set_fileformat)
    def export(self, outfile, level, namespace_='', name_='AbstractCVolume', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractCVolume')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='AbstractCVolume'):
        if self.src is not None:
            outfile.write(' src=%s' % (self.format_string(quote_attrib(self.src).encode(ExternalEncoding), input_name='src'), ))
        if self.dtype is not None:
            outfile.write(' dtype=%s' % (self.format_string(quote_attrib(self.dtype).encode(ExternalEncoding), input_name='dtype'), ))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.fileformat is not None:
            outfile.write(' fileformat=%s' % (self.format_string(quote_attrib(self.fileformat).encode(ExternalEncoding), input_name='fileformat'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractCVolume'):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
    def hasContent_(self):
        if (
            self.description is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractCVolume'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.src is not None:
            showIndent(outfile, level)
            outfile.write('src = "%s",\n' % (self.src,))
        if self.dtype is not None:
            showIndent(outfile, level)
            outfile.write('dtype = "%s",\n' % (self.dtype,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.fileformat is not None:
            showIndent(outfile, level)
            outfile.write('fileformat = "%s",\n' % (self.fileformat,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('src'):
            self.src = attrs.get('src').value
        if attrs.get('dtype'):
            self.dtype = attrs.get('dtype').value
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('fileformat'):
            self.fileformat = attrs.get('fileformat').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'description':
            description_ = ''
            for text__content_ in child_.childNodes:
                description_ += text__content_.nodeValue
            self.description = description_
# end class AbstractCVolume


class AbstractCTrack(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, src=None, name=None, fileformat=None, description=None):
        self.src = _cast(None, src)
        self.name = _cast(None, name)
        self.fileformat = _cast(None, fileformat)
        self.description = description
    def factory(*args_, **kwargs_):
        if AbstractCTrack.subclass:
            return AbstractCTrack.subclass(*args_, **kwargs_)
        else:
            return AbstractCTrack(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    descriptionProp = property(get_description, set_description)
    def get_src(self): return self.src
    def set_src(self, src): self.src = src
    srcProp = property(get_src, set_src)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    nameProp = property(get_name, set_name)
    def get_fileformat(self): return self.fileformat
    def set_fileformat(self, fileformat): self.fileformat = fileformat
    fileformatProp = property(get_fileformat, set_fileformat)
    def export(self, outfile, level, namespace_='', name_='AbstractCTrack', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractCTrack')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='AbstractCTrack'):
        if self.src is not None:
            outfile.write(' src=%s' % (self.format_string(quote_attrib(self.src).encode(ExternalEncoding), input_name='src'), ))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.fileformat is not None:
            outfile.write(' fileformat=%s' % (self.format_string(quote_attrib(self.fileformat).encode(ExternalEncoding), input_name='fileformat'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractCTrack'):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
    def hasContent_(self):
        if (
            self.description is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractCTrack'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.src is not None:
            showIndent(outfile, level)
            outfile.write('src = "%s",\n' % (self.src,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.fileformat is not None:
            showIndent(outfile, level)
            outfile.write('fileformat = "%s",\n' % (self.fileformat,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('src'):
            self.src = attrs.get('src').value
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('fileformat'):
            self.fileformat = attrs.get('fileformat').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'description':
            description_ = ''
            for text__content_ in child_.childNodes:
                description_ += text__content_.nodeValue
            self.description = description_
# end class AbstractCTrack


class AbstractCTimeserie(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, src=None, name=None, fileformat=None, description=None):
        self.src = _cast(None, src)
        self.name = _cast(None, name)
        self.fileformat = _cast(None, fileformat)
        self.description = description
    def factory(*args_, **kwargs_):
        if AbstractCTimeserie.subclass:
            return AbstractCTimeserie.subclass(*args_, **kwargs_)
        else:
            return AbstractCTimeserie(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    descriptionProp = property(get_description, set_description)
    def get_src(self): return self.src
    def set_src(self, src): self.src = src
    srcProp = property(get_src, set_src)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    nameProp = property(get_name, set_name)
    def get_fileformat(self): return self.fileformat
    def set_fileformat(self, fileformat): self.fileformat = fileformat
    fileformatProp = property(get_fileformat, set_fileformat)
    def export(self, outfile, level, namespace_='', name_='AbstractCTimeserie', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractCTimeserie')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='AbstractCTimeserie'):
        if self.src is not None:
            outfile.write(' src=%s' % (self.format_string(quote_attrib(self.src).encode(ExternalEncoding), input_name='src'), ))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.fileformat is not None:
            outfile.write(' fileformat=%s' % (self.format_string(quote_attrib(self.fileformat).encode(ExternalEncoding), input_name='fileformat'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractCTimeserie'):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
    def hasContent_(self):
        if (
            self.description is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractCTimeserie'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.src is not None:
            showIndent(outfile, level)
            outfile.write('src = "%s",\n' % (self.src,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.fileformat is not None:
            showIndent(outfile, level)
            outfile.write('fileformat = "%s",\n' % (self.fileformat,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('src'):
            self.src = attrs.get('src').value
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('fileformat'):
            self.fileformat = attrs.get('fileformat').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'description':
            description_ = ''
            for text__content_ in child_.childNodes:
                description_ += text__content_.nodeValue
            self.description = description_
# end class AbstractCTimeserie


class AbstractKVPair(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, data=None):
        self.data = data
    def factory(*args_, **kwargs_):
        if AbstractKVPair.subclass:
            return AbstractKVPair.subclass(*args_, **kwargs_)
        else:
            return AbstractKVPair(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_data(self): return self.data
    def set_data(self, data): self.data = data
    dataProp = property(get_data, set_data)
    def export(self, outfile, level, namespace_='', name_='AbstractKVPair', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractKVPair')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='AbstractKVPair'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractKVPair'):
        if self.data:
            self.data.export(outfile, level, namespace_, name_='data')
    def hasContent_(self):
        if (
            self.data is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractKVPair'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.data is not None:
            showIndent(outfile, level)
            outfile.write('data=model_.data(\n')
            self.data.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'data':
            obj_ = data.factory()
            obj_.build(child_)
            self.set_data(obj_)
# end class AbstractKVPair


class data(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, key=None, valueOf_=None):
        self.key = _cast(None, key)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if data.subclass:
            return data.subclass(*args_, **kwargs_)
        else:
            return data(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    keyProp = property(get_key, set_key)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='data', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='data')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='data'):
        if self.key is not None:
            outfile.write(' key=%s' % (self.format_string(quote_attrib(self.key).encode(ExternalEncoding), input_name='key'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='data'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='data'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('key = "%s",\n' % (self.key,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('key'):
            self.key = attrs.get('key').value
    def buildChildren(self, child_, nodeName_):
        self.valueOf_ = ''
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class data


class AbstractCNetworkSurface(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, labelid=None, name=None, labelname=None, valueOf_=None):
        self.labelid = _cast(None, labelid)
        self.name = _cast(None, name)
        self.labelname = _cast(None, labelname)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AbstractCNetworkSurface.subclass:
            return AbstractCNetworkSurface.subclass(*args_, **kwargs_)
        else:
            return AbstractCNetworkSurface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_labelid(self): return self.labelid
    def set_labelid(self, labelid): self.labelid = labelid
    labelidProp = property(get_labelid, set_labelid)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    nameProp = property(get_name, set_name)
    def get_labelname(self): return self.labelname
    def set_labelname(self, labelname): self.labelname = labelname
    labelnameProp = property(get_labelname, set_labelname)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='AbstractCNetworkSurface', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractCNetworkSurface')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='AbstractCNetworkSurface'):
        if self.labelid is not None:
            outfile.write(' labelid=%s' % (self.format_string(quote_attrib(self.labelid).encode(ExternalEncoding), input_name='labelid'), ))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.labelname is not None:
            outfile.write(' labelname=%s' % (self.format_string(quote_attrib(self.labelname).encode(ExternalEncoding), input_name='labelname'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractCNetworkSurface'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractCNetworkSurface'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.labelid is not None:
            showIndent(outfile, level)
            outfile.write('labelid = "%s",\n' % (self.labelid,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.labelname is not None:
            showIndent(outfile, level)
            outfile.write('labelname = "%s",\n' % (self.labelname,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('labelid'):
            self.labelid = attrs.get('labelid').value
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('labelname'):
            self.labelname = attrs.get('labelname').value
    def buildChildren(self, child_, nodeName_):
        self.valueOf_ = ''
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class AbstractCNetworkSurface


class AbstractCNetworkVolume(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, segmentationname=None, name=None, valueOf_=None):
        self.segmentationname = _cast(None, segmentationname)
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AbstractCNetworkVolume.subclass:
            return AbstractCNetworkVolume.subclass(*args_, **kwargs_)
        else:
            return AbstractCNetworkVolume(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_segmentationname(self): return self.segmentationname
    def set_segmentationname(self, segmentationname): self.segmentationname = segmentationname
    segmentationnameProp = property(get_segmentationname, set_segmentationname)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    nameProp = property(get_name, set_name)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='AbstractCNetworkVolume', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractCNetworkVolume')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='AbstractCNetworkVolume'):
        if self.segmentationname is not None:
            outfile.write(' segmentationname=%s' % (self.format_string(quote_attrib(self.segmentationname).encode(ExternalEncoding), input_name='segmentationname'), ))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractCNetworkVolume'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractCNetworkVolume'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.segmentationname is not None:
            showIndent(outfile, level)
            outfile.write('segmentationname = "%s",\n' % (self.segmentationname,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('segmentationname'):
            self.segmentationname = attrs.get('segmentationname').value
        if attrs.get('name'):
            self.name = attrs.get('name').value
    def buildChildren(self, child_, nodeName_):
        self.valueOf_ = ''
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class AbstractCNetworkVolume


class AbstractCNetworkTrack(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None):
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AbstractCNetworkTrack.subclass:
            return AbstractCNetworkTrack.subclass(*args_, **kwargs_)
        else:
            return AbstractCNetworkTrack(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    nameProp = property(get_name, set_name)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='AbstractCNetworkTrack', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractCNetworkTrack')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='AbstractCNetworkTrack'):
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractCNetworkTrack'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractCNetworkTrack'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('name'):
            self.name = attrs.get('name').value
    def buildChildren(self, child_, nodeName_):
        self.valueOf_ = ''
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class AbstractCNetworkTrack


class AbstractCNetworkTimeserie(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None):
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AbstractCNetworkTimeserie.subclass:
            return AbstractCNetworkTimeserie.subclass(*args_, **kwargs_)
        else:
            return AbstractCNetworkTimeserie(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    nameProp = property(get_name, set_name)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='AbstractCNetworkTimeserie', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractCNetworkTimeserie')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='AbstractCNetworkTimeserie'):
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractCNetworkTimeserie'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbstractCNetworkTimeserie'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('name'):
            self.name = attrs.get('name').value
    def buildChildren(self, child_, nodeName_):
        self.valueOf_ = ''
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class AbstractCNetworkTimeserie


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def parse(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = connectome.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="connectome", 
        namespacedef_='xmlns="http://www.connectomics.ch/2010/Connectome/xmlns"')
    return rootObj


def parseString(inString):
    doc = minidom.parseString(inString)
    rootNode = doc.documentElement
    rootObj = connectome.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="connectome",
        namespacedef_='xmlns="http://www.connectomics.ch/2010/Connectome/xmlns"')
    return rootObj


def parseLiteral(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = connectome.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from cff import *\n\n')
    sys.stdout.write('import cff as model_\n\n')
    sys.stdout.write('rootObj = model_.connectome(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_="connectome")
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

